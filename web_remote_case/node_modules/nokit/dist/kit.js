// Generated by CoffeeScript 1.8.0
var Promise, colors, fs, k, kit, kitExtendsFsPromise, v, _,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

colors = require('colors');

_ = require('lodash');

Promise = require('bluebird');

fs = require('fs-more');


/**
 * All the async functions in `kit` return promise object.
 * Most time I use it to handle files and system staffs.
 * @type {Object}
 */

kit = {};


/**
 * kit extends all the promise functions of [fs-more][fs-more].
 *
 * [Offline Documentation](?gotoDoc=fs-more/readme.md)
 * [fs-more]: https://github.com/ysmood/fs-more
 * @example
 * ```coffee
 * kit.readFile('test.txt', 'utf8').then (str) ->
 * 	console.log str
 *
 * kit.outputFile 'a.txt', 'test'
 * .then -> kit.log 'done'
 *
 * kit.fs.writeJSONSync 'b.json', { a: 10 }
 * .then -> kit.log 'done'
 *
 * kit.fs.mkdirsP 'b.json', { a: 10 }
 * .then -> kit.log 'done'
 * ```
 */

kitExtendsFsPromise = 'promise';

for (k in fs) {
  v = fs[k];
  if (k.slice(-1) === 'P') {
    kit[k.slice(0, -1)] = fs[k];
  }
}

_.extend(kit, {

  /**
  	 * The lodash lib.
  	 * @type {Object}
   */
  _: _,
  requireCache: {},

  /**
  	 * An throttled version of `Promise.all`, it runs all the tasks under
  	 * a concurrent limitation.
  	 * To run tasks sequentially, use `kit.compose`.
  	 * @param  {Int} limit The max task to run at a time. It's optional.
  	 * Default is Infinity.
  	 * @param  {Array | Function} list
  	 * If the list is an array, it should be a list of functions or promises,
  	 * and each function will return a promise.
  	 * If the list is a function, it should be a iterator that returns
  	 * a promise, hen it returns `undefined`, the iteration ends.
  	 * @param {Boolean} saveResutls Whether to save each promise's result or
  	 * not. Default is true.
  	 * @param {Function} progress If a task ends, the resolve value will be
  	 * passed to this function.
  	 * @return {Promise}
  	 * @example
  	 * ```coffee
  	 * urls = [
  	 * 	'http://a.com'
  	 * 	'http://b.com'
  	 * 	'http://c.com'
  	 * 	'http://d.com'
  	 * ]
  	 * tasks = [
  	 * 	-> kit.request url[0]
  	 * 	-> kit.request url[1]
  	 * 	-> kit.request url[2]
  	 * 	-> kit.request url[3]
  	 * ]
  	 *
  	 * kit.async(tasks).then ->
  	 * 	kit.log 'all done!'
  	 *
  	 * kit.async(2, tasks).then ->
  	 * 	kit.log 'max concurrent limit is 2'
  	 *
  	 * kit.async 3, ->
  	 * 	url = urls.pop()
  	 * 	if url
  	 * 		kit.request url
  	 * .then ->
  	 * 	kit.log 'all done!'
  	 * ```
   */
  async: function(limit, list, saveResutls, progress) {
    var from, isIterDone, iter, iterIndex, listLen, resutls, running;
    from = 0;
    resutls = [];
    iterIndex = 0;
    running = 0;
    isIterDone = false;
    if (!_.isNumber(limit)) {
      progress = saveResutls;
      saveResutls = list;
      list = limit;
      limit = Infinity;
    }
    if (saveResutls == null) {
      saveResutls = true;
    }
    if (_.isArray(list)) {
      listLen = list.length - 1;
      iter = function(i) {
        if (i > listLen) {
          return;
        }
        if (_.isFunction(list[i])) {
          return list[i](i);
        } else {
          return list[i];
        }
      };
    } else if (_.isFunction(list)) {
      iter = list;
    } else {
      Promise.reject(new Error('unknown list type: ' + typeof list));
    }
    return new Promise(function(resolve, reject) {
      var addTask, allDone, i, _i, _results;
      addTask = function() {
        var p, task;
        task = iter(iterIndex++);
        if (isIterDone || task === void 0) {
          isIterDone = true;
          if (running === 0) {
            allDone();
          }
          return false;
        }
        if (_.isFunction(task.then)) {
          p = task;
        } else {
          p = Promise.resolve(task);
        }
        running++;
        p.then(function(ret) {
          running--;
          if (saveResutls) {
            resutls.push(ret);
          }
          if (typeof progress === "function") {
            progress(ret);
          }
          return addTask();
        })["catch"](function(err) {
          running--;
          return reject(err);
        });
        return true;
      };
      allDone = function() {
        if (saveResutls) {
          return resolve(resutls);
        } else {
          return resolve();
        }
      };
      _results = [];
      for (i = _i = 0; 0 <= limit ? _i < limit : _i > limit; i = 0 <= limit ? ++_i : --_i) {
        if (!addTask()) {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  },

  /**
  	 * Creates a function that is the composition of the provided functions.
  	 * Besides, it can also accept async function that returns promise.
  	 * It's more powerful than `_.compose`, and it use reverse order for
  	 * passing argument from one function to another.
  	 * See `kit.async`, if you need concurrent support.
  	 * @param  {Function | Array} fns Functions that return
  	 * promise or any value.
  	 * And the array can also contains promises.
  	 * @return {Function} A composed function that will return a promise.
  	 * @example
  	 * ```coffee
  	 * # It helps to decouple sequential pipeline code logic.
  	 *
  	 * createUrl = (name) ->
  	 * 	return "http://test.com/" + name
  	 *
  	 * curl = (url) ->
  	 * 	kit.request(url).then ->
  	 * 		kit.log 'get'
  	 *
  	 * save = (str) ->
  	 * 	kit.outputFile('a.txt', str).then ->
  	 * 		kit.log 'saved'
  	 *
  	 * download = kit.compose createUrl, curl, save
  	 * # same as "download = kit.compose [createUrl, curl, save]"
  	 *
  	 * download 'home'
  	 * ```
   */
  compose: function() {
    var fns;
    fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function(val) {
      if (_.isArray(fns[0])) {
        fns = fns[0];
      }
      return fns.reduce(function(preFn, fn) {
        if (_.isFunction(fn.then)) {
          return preFn.then(function() {
            return fn;
          });
        } else {
          return preFn.then(fn);
        }
      }, Promise.resolve(val));
    };
  },

  /**
  	 * Daemonize a program. Just a shortcut usage of `kit.spawn`.
  	 * @param  {Object} opts Defaults:
  	 * ```coffee
  	 * {
  	 * 	bin: 'node'
  	 * 	args: ['app.js']
  	 * 	stdout: 'stdout.log' # Can also be a stream
  	 * 	stderr: 'stderr.log' # Can also be a stream
  	 * }
  	 * ```
  	 * @return {Porcess} The daemonized process.
   */
  daemonize: function(opts) {
    var errLog, outLog, p;
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      bin: 'node',
      args: ['app.js'],
      stdout: 'stdout.log',
      stderr: 'stderr.log'
    });
    if (_.isString(opts.stdout)) {
      outLog = kit.fs.openSync(opts.stdout, 'a');
    }
    if (_.isString(opts.stderr)) {
      errLog = kit.fs.openSync(opts.stderr, 'a');
    }
    p = kit.spawn(opts.bin, opts.args, {
      detached: true,
      stdio: ['ignore', outLog, errLog]
    }).process;
    p.unref();
    return p;
  },

  /**
  	 * A simple decrypt helper. Cross-version of node.
  	 * @param  {Any} data
  	 * @param  {String | Buffer} password
  	 * @param  {String} algorithm Default is 'aes128'.
  	 * @return {Buffer}
   */
  decrypt: function(data, password, algorithm) {
    var crypto, decipher;
    if (algorithm == null) {
      algorithm = 'aes128';
    }
    crypto = kit.require('crypto');
    decipher = crypto.createDecipher(algorithm, password);
    if (kit.nodeVersion() < 0.10) {
      if (Buffer.isBuffer(data)) {
        data = data.toString('binary');
      }
      return new Buffer(decipher.update(data, 'binary') + decipher.final(), 'binary');
    } else {
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data);
      }
      return Buffer.concat([decipher.update(data), decipher.final()]);
    }
  },

  /**
  	 * A simple encrypt helper. Cross-version of node.
  	 * @param  {Any} data
  	 * @param  {String | Buffer} password
  	 * @param  {String} algorithm Default is 'aes128'.
  	 * @return {Buffer}
   */
  encrypt: function(data, password, algorithm) {
    var cipher, crypto;
    if (algorithm == null) {
      algorithm = 'aes128';
    }
    crypto = kit.require('crypto');
    cipher = crypto.createCipher(algorithm, password);
    if (kit.nodeVersion() < 0.10) {
      if (Buffer.isBuffer(data)) {
        data = data.toString('binary');
      }
      return new Buffer(cipher.update(data, 'binary') + cipher.final(), 'binary');
    } else {
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data);
      }
      return Buffer.concat([cipher.update(data), cipher.final()]);
    }
  },

  /**
  	 * A error log shortcut for `kit.log(msg, 'error', opts)`
  	 * @param  {Any} msg
  	 * @param  {Object} opts
   */
  err: function(msg, opts) {
    if (opts == null) {
      opts = {};
    }
    return kit.log(msg, 'error', opts);
  },

  /**
  	 * A better `child_process.exec`. Supports multi-line shell script.
  	 * For supporting old node version, it will create 3 temp files,
  	 * the temp files will be removed after the execution.
  	 * @param  {String} cmd   Shell commands.
  	 * @param  {String} shell Shell name. Such as `bash`, `zsh`. Optinal.
  	 * @return {Promise} Resolves when the process's stdio is drained.
  	 * The resolve value is like:
  	 * ```coffee
  	 * {
  	 * 	code: 0
  	 * 	signal: null
  	 * 	stdout: 'hello world'
  	 * 	stderr: ''
  	 * }
  	 * ```
  	 * @example
  	 * ```coffee
  	 * kit.exec("""
  	 * 	a='hello world'
  	 *  echo $a
  	 * """).then ({code, stdout}) ->
  	 * 	kit.log code # output => 0
  	 * 	kit.log stdout # output => "hello world"
  	 *
  	 * # Bash doesn't support "**" recusive match pattern.
  	 * kit.exec """
  	 * 	echo **\/*.css
  	 * """, 'zsh'
  	 * ```
   */
  exec: function(cmd, shell) {
    var clean, fileHandlers, os, paths, promise, randName, stderrPath, stdinPath, stdoutPath;
    os = kit.require('os');
    if (shell == null) {
      shell = process.env.SHELL || process.env.ComSpec || process.env.COMSPEC;
    }
    randName = Date.now() + Math.random();
    paths = ['.in', '.out', '.err'].map(function(type) {
      return kit.path.join(os.tmpDir(), 'nobone-' + randName + type);
    });
    stdinPath = paths[0], stdoutPath = paths[1], stderrPath = paths[2];
    fileHandlers = [];
    clean = function() {
      return Promise.all(fileHandlers.map(function(f) {
        return kit.close(f);
      })).then(function() {
        return Promise.all(paths.map(function(p) {
          return kit.remove(p);
        }));
      });
    };
    promise = kit.outputFile(stdinPath, cmd).then(function() {
      return Promise.all([kit.fs.openP(stdinPath, 'r'), kit.fs.openP(stdoutPath, 'w'), kit.fs.openP(stderrPath, 'w')]);
    }).then(function(stdio) {
      fileHandlers = fileHandlers.concat(stdio);
      return kit.spawn(shell, [], {
        stdio: stdio
      });
    }).then(function(msg) {
      return Promise.all([kit.readFile(stdoutPath, 'utf8'), kit.readFile(stderrPath, 'utf8')]).then(function(_arg) {
        var stderr, stdout;
        stdout = _arg[0], stderr = _arg[1];
        return _.extend(msg, {
          stdout: stdout,
          stderr: stderr
        });
      });
    });
    promise.then(clean)["catch"](clean);
    return promise;
  },

  /**
  	 * See my project [fs-more][fs-more].
  	 *
  	 * [Offline Documentation](?gotoDoc=fs-more/readme.md)
  	 * [fs-more]: https://github.com/ysmood/fs-more
   */
  fs: fs,

  /**
  	 * Generate a list of module paths from a name and a directory.
  	 * @param  {String} moduleName The module name.
  	 * @param  {String} dir        The root path. Default is current working dir.
  	 * @return {Array} Paths
   */
  generateNodeModulePaths: function(moduleName, dir) {
    var names, pDir;
    if (dir == null) {
      dir = process.cwd();
    }
    names = [moduleName];
    while (true) {
      names.push(kit.path.join(dir, 'node_modules', moduleName));
      pDir = kit.path.dirname(dir);
      if (dir === pDir) {
        break;
      }
      dir = pDir;
    }
    return names;
  },

  /**
  	 * A handy file system search tool.
  	 * See the https://github.com/isaacs/node-glob
  	 *
  	 * [Offline Documentation](?gotoDoc=glob/readme.md)
  	 * @param {String | Array} patterns Minimatch pattern.
  	 * @param {Object} opts The glob options.
  	 * @return {Promise} Contains the path list.
  	 * @example
  	 * ```coffee
  	 * glob('*.js').then (paths) -> kit.log paths
  	 *
  	 * glob('*.js', { cwd: 'test' }).then (paths) -> kit.log paths
  	 *
  	 * glob(['*.js', '*.css']).then (paths) -> kit.log paths
  	 *
  	 * # The 'statCache' is also saved.
  	 * glob('*.js', { dot: true }).then (paths) ->
  	 * 	kit.log paths.statCache
  	 * ```
   */
  glob: function(patterns, opts) {
    var allPaths, statCache;
    if (_.isString(patterns)) {
      patterns = [patterns];
    }
    allPaths = [];
    statCache = {};
    return Promise.all(patterns.map(function(p) {
      return kit._glob(p, opts).then(function(paths) {
        _.extend(statCache, paths.glob.statCache);
        return allPaths = _.union(allPaths, paths);
      });
    })).then(function() {
      return Object.defineProperty(allPaths, 'statCache', {
        value: statCache,
        enumerable: false
      });
    });
  },
  _glob: function(pattern, opts) {
    var glob;
    glob = kit.require('glob');
    return new Promise(function(resolve, reject) {
      var err, g, paths;
      if (opts && opts.sync) {
        try {
          g = new glob.Glob(pattern, opts);
          paths = g.found;
          paths.glob = g;
          return resolve(paths);
        } catch (_error) {
          err = _error;
          return reject(err);
        }
      } else {
        return g = glob(pattern, opts, function(err, paths) {
          paths.glob = g;
          if (err) {
            return reject(err);
          } else {
            return resolve(paths);
          }
        });
      }
    });
  },

  /**
  	 * A fast helper to hash string or binary file.
  	 * See my [jhash][jhash] project.
  	 *
  	 * [Offline Documentation](?gotoDoc=jhash/readme.md)
  	 * [jhash]: https://github.com/ysmood/jhash
  	 * @example
  	 * ```coffee
  	 * var jhash = require('jhash');
  	 * jhash.hash('test'); // output => '349o'
  	 *
  	 * var fs = require('fs');
  	 * jhash.hash(fs.readFileSync('a.jpg'));
  	 *
  	 * // Control the hash char set.
  	 * jhash.setSymbols('abcdef');
  	 * jhash.hash('test'); // output => 'decfddfe'
  	 *
  	 * // Control the max length of the result hash value. Unit is bit.
  	 * jhash.setMaskLen(10);
  	 * jhash.hash('test'); // output => 'ede'
  	 * ```
   */
  jhash: require('jhash'),

  /**
  	 * It inserts the fnB in between the fnA and concatenates the result.
  	 * @param  {Any} fnA
  	 * @param  {Any} fnB
  	 * @return {Array}
  	 * @example
  	 * ```coffee
  	 * kit.join([1, 2, 3, 4], 'sep')
  	 * # output => [1, 'sep', 2, 'sep', 3, 'sep', 4]
  	 *
  	 * iter = ->
  	 * 	i = 0
  	 * 	-> i++
  	 * kit.join([1, 2, 3, 4], new iter)
  	 * # output => [1, 'sep', 2, 'sep', 3, 'sep', 4]
  	 * ```
   */
  join: function(fnA, fnB) {
    var arr, iterA, iterB, nextVal, val;
    arr = [];
    iterA = kit.iter(fnA);
    iterB = kit.iter(fnB);
    val = iterA().value;
    while (val !== void 0) {
      arr.push(val);
      nextVal = iterA().value;
      if (nextVal !== void 0) {
        arr.push(iterB().value);
      }
      val = nextVal;
    }
    return arr;
  },

  /**
  	 * Generate a iterator from a value.
  	 * @param  {Any} val
  	 * @return {Function} The every time when the function been
  	 * called, it returns a object looks like:
  	 * ```coffee
  	 * { key: 10, value: 'hello world' }
  	 * ```
  	 * The `key` can be `undefined`, `number` or `string`.
  	 * @example
  	 * ```coffee
  	 * iter = kit.iter [1, 2, 3]
  	 * iter() # output => { key: 0, value: 1 }
  	 *
  	 * iter = kit.iter 'test'
  	 * iter() # output => { key: 0, value: 't' }
  	 *
  	 * iter = kit.iter { a: 1, b: 2, c: 3 }
  	 * iter() # output => { key: 'a', value: 1 }
  	 * ```
   */
  iter: function(val) {
    var i, keys;
    if (_.isArray(val)) {
      i = 0;
      return function() {
        return {
          key: i,
          value: val[i++]
        };
      };
    } else if (_.isFunction(val)) {
      return function() {
        return {
          value: val.apply(void 0, arguments)
        };
      };
    } else if (_.isObject(val)) {
      i = 0;
      keys = _.keys(val);
      return function() {
        var key;
        key = keys[i++];
        return {
          key: key,
          value: val[key]
        };
      };
    } else {
      return function() {
        return {
          value: val
        };
      };
    }
  },

  /**
  	 * For debugging. Dump a colorful object.
  	 * @param  {Object} obj Your target object.
  	 * @param  {Object} opts Options. Default:
  	 * ```coffee
  	 * { colors: true, depth: 5 }
  	 * ```
  	 * @return {String}
   */
  inspect: function(obj, opts) {
    var str, util;
    util = kit.require('util');
    _.defaults(opts, {
      colors: kit.isDevelopment(),
      depth: 5
    });
    return str = util.inspect(obj, opts);
  },

  /**
  	 * Nobone use it to check the running mode of the app.
  	 * Overwrite it if you want to control the check logic.
  	 * By default it returns the `rocess.env.NODE_ENV == 'development'`.
  	 * @return {Boolean}
   */
  isDevelopment: function() {
    return process.env.NODE_ENV === 'development';
  },

  /**
  	 * Nobone use it to check the running mode of the app.
  	 * Overwrite it if you want to control the check logic.
  	 * By default it returns the `rocess.env.NODE_ENV == 'production'`.
  	 * @return {Boolean}
   */
  isProduction: function() {
    return process.env.NODE_ENV === 'production';
  },

  /**
  	 * A better log for debugging, it uses the `kit.inspect` to log.
  	 *
  	 * Use terminal command like `logReg='pattern' node app.js` to
  	 * filter the log info.
  	 *
  	 * Use `logTrace='on' node app.js` to force each log end with a
  	 * stack trace.
  	 * @param  {Any} msg Your log message.
  	 * @param  {String} action 'log', 'error', 'warn'.
  	 * @param  {Object} opts Default is same with `kit.inspect`
   */
  log: function(msg, action, opts) {
    var log, time, timeDelta;
    if (action == null) {
      action = 'log';
    }
    if (opts == null) {
      opts = {};
    }
    if (!kit.lastLogTime) {
      kit.lastLogTime = new Date;
      if (process.env.logReg) {
        kit.logReg = new RegExp(process.env.logReg);
      }
    }
    time = new Date();
    timeDelta = (+time - +kit.lastLogTime).toString().magenta + 'ms';
    kit.lastLogTime = time;
    time = [[kit.pad(time.getFullYear(), 4), kit.pad(time.getMonth() + 1, 2), kit.pad(time.getDate(), 2)].join('-'), [kit.pad(time.getHours(), 2), kit.pad(time.getMinutes(), 2), kit.pad(time.getSeconds(), 2)].join(':')].join(' ').grey;
    log = function() {
      var err, str;
      str = _.toArray(arguments).join(' ');
      if (kit.logReg && !kit.logReg.test(str)) {
        return;
      }
      console[action](str.replace(/\n/g, '\n  '));
      if (process.env.logTrace === 'on') {
        err = (new Error).stack.replace(/.+\n.+\n.+/, '\nStack trace:').grey;
        return console.log(err);
      }
    };
    if (_.isObject(msg)) {
      log(("[" + time + "] ->\n") + kit.inspect(msg, opts), timeDelta);
    } else {
      log("[" + time + "]", msg, timeDelta);
    }
    if (action === 'error') {
      process.stdout.write("\u0007");
    }
  },

  /**
  	 * Monitor an application and automatically restart it when file changed.
  	 * Even when the monitored app exit with error, the monitor will still wait
  	 * for your file change to restart the application. Not only nodejs, but also
  	 * other programs like ruby or python.
  	 * It will print useful infomation when it application unexceptedly.
  	 * @param  {Object} opts Defaults:
  	 * ```coffee
  	 * {
  	 * 	bin: 'node'
  	 * 	args: ['index.js']
  	 * 	watchList: [] # By default, the same with the "args".
  	 * 	isNodeDeps: false
  	 * 	opts: {} # Same as the opts of 'kit.spawn'.
  	 *
  	 * 	# The option of `kit.parseDependency`
  	 * 	parseDependency: {}
  	 *
  	 *	onStart: ->
  	 *		kit.log "Monitor: ".yellow + opts.watchList
  	 *	onRestart: (path) ->
  	 *		kit.log "Reload app, modified: ".yellow + path
  	 *	onNormalExit: ({ code, signal }) ->
  	 *		kit.log 'EXIT'.yellow +
  	 *			" code: #{(code + '').cyan} signal: #{(signal + '').cyan}"
  	 *	onErrorExit: ->
  	 *		kit.err 'Process closed. Edit and save
  	 *			the watched file to restart.'.red
  	 *	sepLine: ->
  	 *		chars = _.times(process.stdout.columns, -> '*')
  	 *		console.log chars.join('').yellow
  	 * }
  	 * ```
  	 * @return {Promise} It has a property `process`, which is the monitored
  	 * child process.
  	 * @example
  	 * ```coffee
  	 * kit.monitorApp {
  	 * 	bin: 'coffee'
  	 * 	args: ['main.coffee']
  	 * }
  	 *
  	 * kit.monitorApp {
  	 * 	bin: 'ruby'
  	 * 	args: ['app.rb', 'lib\/**\/*.rb']
  	 * 	isNodeDeps: false
  	 * }
  	 * ```
   */
  monitorApp: function(opts) {
    var childPromise, start, watcher;
    _.defaults(opts, {
      bin: 'node',
      args: ['index.js'],
      watchList: null,
      isNodeDeps: true,
      parseDependency: {},
      opts: {},
      onStart: function() {
        return kit.log("Monitor: ".yellow + opts.watchList);
      },
      onRestart: function(path) {
        return kit.log("Reload app, modified: ".yellow + path);
      },
      onNormalExit: function(_arg) {
        var code, signal;
        code = _arg.code, signal = _arg.signal;
        return kit.log('EXIT'.yellow + (" code: " + (code + '').cyan + " signal: " + (signal + '').cyan));
      },
      onErrorExit: function() {
        return kit.err('Process closed. Edit and save the watched file to restart.'.red);
      },
      sepLine: function() {
        var chars;
        chars = _.times(process.stdout.columns, function() {
          return '*';
        });
        return console.log(chars.join('').yellow);
      }
    });
    if (opts.watchList == null) {
      opts.watchList = opts.args;
    }
    childPromise = null;
    start = function() {
      opts.sepLine();
      childPromise = kit.spawn(opts.bin, opts.args, opts.opts);
      return childPromise.then(function(msg) {
        return opts.onNormalExit(msg);
      })["catch"](function(err) {
        if (err.stack) {
          return Promise.reject(err.stack);
        }
        return opts.onErrorExit();
      });
    };
    watcher = function(path, curr, prev) {
      if (curr.mtime !== prev.mtime) {
        opts.onRestart(path);
        childPromise["catch"](function() {}).then(start);
        return childPromise.process.kill('SIGINT');
      }
    };
    process.on('SIGINT', function() {
      childPromise.process.kill('SIGINT');
      return process.exit();
    });
    if (opts.isNodeDeps) {
      kit.parseDependency(opts.watchList, opts.parseDependency).then(function(paths) {
        return kit.watchFiles(paths, watcher);
      });
    } else {
      kit.watchFiles(opts.watchList, watcher);
    }
    opts.onStart();
    start();
    return childPromise;
  },

  /**
  	 * Node version. Such as `v0.10.23` is `0.1023`, `v0.10.1` is `0.1001`.
  	 * @type {Float}
   */
  nodeVersion: function() {
    var ms, str;
    ms = process.versions.node.match(/(\d+)\.(\d+)\.(\d+)/);
    str = ms[1] + '.' + kit.pad(ms[2], 2) + kit.pad(ms[3], 2);
    return +str;
  },

  /**
  	 * Open a thing that your system can recognize.
  	 * Now only support Windows, OSX or system that installed 'xdg-open'.
  	 * @param  {String} cmd  The thing you want to open.
  	 * @param  {Object} opts The options of the node native
  	 * `child_process.exec`.
  	 * @return {Promise} When the child process exits.
  	 * @example
  	 * ```coffee
  	 * # Open a webpage with the default browser.
  	 * kit.open 'http://ysmood.org'
  	 * ```
   */
  open: function(cmd, opts) {
    var cmds, exec, which;
    if (opts == null) {
      opts = {};
    }
    exec = kit.require('child_process').exec;
    switch (process.platform) {
      case 'darwin':
        cmds = ['open'];
        break;
      case 'win32':
        cmds = ['start'];
        break;
      default:
        which = kit.require('which');
        try {
          cmds = [which.sync('xdg-open')];
        } catch (_error) {
          return Promise.resolve();
        }
    }
    cmds.push(cmd);
    return new Promise(function(resolve, reject) {
      return exec(cmds.join(' '), opts, function(err, stdout, stderr) {
        if (err) {
          return reject(err);
        } else {
          return resolve({
            stdout: stdout,
            stderr: stderr
          });
        }
      });
    });
  },

  /**
  	 * String padding helper. It is used in the `kit.log`.
  	 * @param  {Sting | Number} str
  	 * @param  {Number} width
  	 * @param  {String} char Padding char. Default is '0'.
  	 * @return {String}
  	 * @example
  	 * ```coffee
  	 * kit.pad '1', 3 # '001'
  	 * ```
   */
  pad: function(str, width, char) {
    if (char == null) {
      char = '0';
    }
    str = str + '';
    if (str.length >= width) {
      return str;
    } else {
      return new Array(width - str.length + 1).join(char) + str;
    }
  },

  /**
  	 * A comments parser for coffee-script.
  	 * Used to generate documentation from source code automatically.
  	 * It will traverse through all the comments of a coffee file.
  	 * @param  {String} moduleName The name of the module it belongs to.
  	 * @param  {String} code Coffee source code.
  	 * @param  {String} path The path of the source code.
  	 * @param  {Object} opts Parser options:
  	 * ```coffee
  	 * {
  	 * 	commentReg: RegExp
  	 * 	splitReg: RegExp
  	 * 	tagNameReg: RegExp
  	 * 	typeReg: RegExp
  	 * 	nameReg: RegExp
  	 * 	nameTags: ['param', 'property']
  	 * 	descriptionReg: RegExp
  	 * }
  	 * ```
  	 * @return {Array} The parsed comments. Each item is something like:
  	 * ```coffee
  	 * {
  	 * 	module: 'nobone'
  	 * 	name: 'parseComment'
  	 * 	description: 'A comments parser for coffee-script.'
  	 * 	tags: [
  	 * 		{
  	 * 			tagName: 'param'
  	 * 			type: 'string'
  	 * 			name: 'code'
  	 * 			description: 'The name of the module it belongs to.'
  	 * 			path: 'http://thePathOfSourceCode'
  	 * 			index: 256 # The target char index in the file.
  	 * 			line: 32 # The line number of the target in the file.
  	 * 		}
  	 * 	]
  	 * }
  	 * ```
   */
  parseComment: function(moduleName, code, path, opts) {
    var comments, info, m, parseInfo;
    if (path == null) {
      path = '';
    }
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      commentReg: /###\*([\s\S]+?)###\s+([\w\.]+)/g,
      splitReg: /^\s+\* @/m,
      tagNameReg: /^([\w\.]+)\s*/,
      typeReg: /^\{(.+?)\}\s*/,
      nameReg: /^(\w+)\s*/,
      nameTags: ['param', 'property'],
      descriptionReg: /^([\s\S]*)/
    });
    parseInfo = function(block) {
      var arr;
      block = block.replace(/\\\//g, '/');
      arr = block.split(opts.splitReg).map(function(el) {
        return el.replace(/^[ \t]+\*[ \t]?/mg, '').trim();
      });
      return {
        description: arr[0] || '',
        tags: arr.slice(1).map(function(el) {
          var parseTag, tag, type, _ref;
          parseTag = function(reg) {
            var m;
            m = el.match(reg);
            if (m && m[1]) {
              el = el.slice(m[0].length);
              return m[1];
            } else {
              return null;
            }
          };
          tag = {};
          tag.tagName = parseTag(opts.tagNameReg);
          type = parseTag(opts.typeReg);
          if (type) {
            tag.type = type;
            if (_ref = tag.tagName, __indexOf.call(opts.nameTags, _ref) >= 0) {
              tag.name = parseTag(opts.nameReg);
            }
            tag.description = parseTag(opts.descriptionReg) || '';
          } else {
            tag.description = parseTag(opts.descriptionReg) || '';
          }
          return tag;
        })
      };
    };
    comments = [];
    m = null;
    while ((m = opts.commentReg.exec(code)) !== null) {
      info = parseInfo(m[1]);
      comments.push({
        module: moduleName,
        name: m[2],
        description: info.description,
        tags: info.tags,
        path: path,
        index: opts.commentReg.lastIndex,
        line: _.reduce(code.slice(0, opts.commentReg.lastIndex), function(count, char) {
          if (char === '\n') {
            count++;
          }
          return count;
        }, 1)
      });
    }
    return comments;
  },

  /**
  	 * Parse dependency tree by regex. The dependency relationships
  	 * is not a tree, but a graph. To avoid dependency cycle, this
  	 * function only return an linear array of the dependencies,
  	 * from which you won't get the detail relationshops between files.
  	 * @param  {String | Array} entryPaths The file to begin with.
  	 * @param  {Object} opts Defaults:
  	 * ```coffee
  	 * {
  	 * 	depReg: /require\s*\(?['"](.+)['"]\)?/gm
  	 * 	depRoots: ['']
  	 * 	extensions: ['.js', '.coffee', 'index.js', 'index.coffee']
  	 *
  	 * 	# It will handle all the matched paths.
  	 * 	# Return false value if you don't want this match.
  	 * 	handle: (path) ->
  	 * 		path.replace(/^[\s'"]+/, '').replace(/[\s'";]+$/, '')
  	 * }
  	 * ```
  	 * @return {Promise} It resolves the dependency path array.
  	 * @example
  	 * ```coffee
  	 * kit.parseDependency 'main.', {
  	 * 	depReg: /require\s*\(?['"](.+)['"]\)?/gm
  	 *  handle: (path) ->
  	 * 		return if path[0] != '.'
  	 * 		path.replace(/^[\s'"]+/, '').replace(/[\s'";]+$/, '')
  	 * }
  	 * ```
   */
  parseDependency: function(entryPaths, opts, depPaths) {
    if (opts == null) {
      opts = {};
    }
    if (depPaths == null) {
      depPaths = {};
    }
    _.defaults(opts, {
      depReg: /require\s*\(?['"](.+)['"]\)?/g,
      depRoots: [''],
      extensions: ['.js', '.coffee', '/index.js', '/index.coffee'],
      handle: function(path) {
        if (path.match(/^(?:\.|\/|[a-z]:)/i)) {
          return path;
        }
      }
    });
    if (_.isString(entryPaths)) {
      entryPaths = [entryPaths];
    }
    entryPaths = entryPaths.reduce(function(s, p) {
      if (kit.path.extname(p)) {
        return s.concat([p]);
      } else {
        return s.concat(opts.extensions.map(function(ext) {
          return p + ext;
        }));
      }
    }, []);
    if (opts.depRoots.indexOf('') === -1) {
      opts.depRoots.push('');
    }
    entryPaths = entryPaths.reduce(function(s, p) {
      return s.concat(opts.depRoots.map(function(root) {
        return kit.path.join(root, p);
      }));
    }, []);
    return kit.glob(entryPaths, {
      nosort: true
    }).then(function(paths) {
      return Promise.all(paths.map(function(path) {
        if (depPaths[path]) {
          return;
        }
        return kit.readFile(path, 'utf8').then(function(str) {
          var dir;
          depPaths[path] = true;
          dir = kit.path.dirname(path);
          entryPaths = [];
          str.replace(opts.depReg, function(m, p) {
            p = opts.handle(p);
            if (!p) {
              return;
            }
            entryPaths.push(p);
            return entryPaths.push(kit.path.join(dir, p));
          });
          return kit.parseDependency(entryPaths, opts, depPaths);
        });
      }));
    }).then(function() {
      return _.keys(depPaths);
    });
  },

  /**
  	 * Node native module `path`.
   */
  path: require('path'),

  /**
  	 * The promise lib. Now, it uses Bluebird as ES5 polyfill.
  	 * In the future, the Bluebird will be replaced with native
  	 * ES6 Promise. Please don't use any API other than the ES6 spec.
  	 * @type {Object}
   */
  Promise: Promise,

  /**
  	 * Convert a callback style function to a promise function.
  	 * @param  {Function} fn
  	 * @param  {Any}      this `this` object of the function.
  	 * @return {Function} The function will return a promise object.
  	 * @example
  	 * ```coffee
  	 * readFile = kit.promisify fs.readFile, fs
  	 * readFile('a.txt').then kit.log
  	 * ```
   */
  promisify: function(fn, self) {
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new Promise(function(resolve, reject) {
        args.push(function() {
          if (arguments[0] != null) {
            return reject(arguments[0]);
          } else {
            return resolve(arguments[1]);
          }
        });
        return fn.apply(self, args);
      });
    };
  },

  /**
  	 * Much faster than the native require of node, but you should
  	 * follow some rules to use it safely.
  	 * @param  {String}   moduleName Relative moudle path is not allowed!
  	 * Only allow absolute path or module name.
  	 * @param  {Function} done Run only the first time after the module loaded.
  	 * @return {Module} The module that you require.
   */
  require: function(moduleName, done) {
    var name, names, p, _i, _j, _len, _len1, _ref;
    if (!kit.requireCache[moduleName]) {
      if (moduleName[0] === '.') {
        throw new Error('Relative path is not allowed: ' + moduleName);
      }
      names = kit.generateNodeModulePaths(moduleName, process.cwd());
      if (process.env.NODE_PATH) {
        _ref = process.env.NODE_PATH.split(kit.path.delimiter);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          names.push(kit.path.join(p, moduleName));
        }
      }
      for (_j = 0, _len1 = names.length; _j < _len1; _j++) {
        name = names[_j];
        try {
          kit.requireCache[moduleName] = require(name);
          if (typeof done === "function") {
            done(kit.requireCache[moduleName]);
          }
          break;
        } catch (_error) {}
      }
    }
    if (!kit.requireCache[moduleName]) {
      throw new Error('Module not found: ' + moduleName);
    }
    return kit.requireCache[moduleName];
  },

  /**
  	 * Require an optional package. If not found, it will
  	 * warn user to npm install it, and exit the process.
  	 * @param  {String} name Package name
  	 * @return {Any} The required package.
   */
  requireOptional: function(name) {
    var err;
    try {
      return kit.require(name);
    } catch (_error) {
      err = _error;
      console.error(err.stack + "\nError: Please ".red + ("'npm install " + name + "'").green + " first. If it is a global lib, ".red + ("'npm install -g " + name + "'").green + " first.".red);
      return process.exit();
    }
  },

  /**
  	 * A handy extended combination of `http.request` and `https.request`.
  	 * @param  {Object} opts The same as the [http.request](http://nodejs.org/api/http.html#httpHttpRequestOptionsCallback),
  	 * but with some extra options:
  	 * ```coffee
  	 * {
  	 * 	url: 'It is not optional, String or Url Object.'
  	 *
  	 * 	# Other than return `res` with `res.body`,return `body` directly.
  	 * 	body: true
  	 *
  	 * 	# Max times of auto redirect. If 0, no auto redirect.
  	 * 	redirect: 0
  	 *
  	 * 	# Timeout of the socket of the http connection.
  	 * 	# If timeout happens, the promise will reject.
  	 * 	# Zero means no timeout.
  	 * 	timeout: 0
  	 *
  	 * 	# The key of headers should be lowercased.
  	 * 	headers: {}
  	 *
  	 * 	host: 'localhost'
  	 * 	hostname: 'localhost'
  	 * 	port: 80
  	 * 	method: 'GET'
  	 * 	path: '/'
  	 * 	auth: ''
  	 * 	agent: null
  	 *
  	 * 	# Set "transfer-encoding" header to 'chunked'.
  	 * 	setTE: false
  	 *
  	 * 	# Set null to use buffer, optional.
  	 * 	# It supports GBK, ShiftJIS etc.
  	 * 	# For more info, see https://github.com/ashtuchkin/iconv-lite
  	 * 	resEncoding: 'auto'
  	 *
  	 * 	# It's string, object or buffer, optional. When it's an object,
  	 * 	# The request will be 'application/x-www-form-urlencoded'.
  	 * 	reqData: null
  	 *
  	 * 	# auto end the request.
  	 * 	autoEndReq: true
  	 *
  	 * 	# Readable stream.
  	 * 	reqPipe: null
  	 *
  	 * 	# Writable stream.
  	 * 	resPipe: null
  	 *
  	 * 	# The progress of the request.
  	 * 	reqProgress: (complete, total) ->
  	 *
  	 * 	# The progress of the response.
  	 * 	resProgress: (complete, total) ->
  	 * }
  	 * ```
  	 * And if set opts as string, it will be treated as the url.
  	 * @return {Promise} Contains the http response object,
  	 * it has an extra `body` property.
  	 * You can also get the request object by using `Promise.req`.
  	 * @example
  	 * ```coffee
  	 * p = kit.request 'http://test.com'
  	 * p.req.on 'response', (res) ->
  	 * 	kit.log res.headers['content-length']
  	 * p.then (body) ->
  	 * 	kit.log body # html or buffer
  	 *
  	 * kit.request {
  	 * 	url: 'https://test.com/a.mp3'
  	 * 	body: false
  	 * 	resProgress: (complete, total) ->
  	 * 		kit.log "Progress: #{complete} / #{total}"
  	 * }
  	 * .then (res) ->
  	 * 	kit.log res.body.length
  	 * 	kit.log res.headers
  	 *
  	 * # Send form-data.
  	 * form = new (require 'form-data')
  	 * form.append 'a.jpg', new Buffer(0)
  	 * form.append 'b.txt', 'hello world!'
  	 * kit.request {
  	 * 	url: 'a.com'
  	 * 	headers: form.getHeaders()
  	 * 	setTE: true
  	 * 	reqPipe: form
  	 * }
  	 * .then (body) ->
  	 * 	kit.log body
  	 * ```
   */
  request: function(opts) {
    var promise, req, reqBuf, request, url, _base, _base1, _base2;
    if (_.isString(opts)) {
      opts = {
        url: opts
      };
    }
    if (_.isObject(opts.url)) {
      if ((_base = opts.url).protocol == null) {
        _base.protocol = 'http:';
      }
      opts.url = kit.url.format(opts.url);
    } else {
      if (opts.url.indexOf('http') !== 0) {
        opts.url = 'http://' + opts.url;
      }
    }
    url = kit.url.parse(opts.url);
    delete url.host;
    if (url.protocol == null) {
      url.protocol = 'http:';
    }
    request = null;
    switch (url.protocol) {
      case 'http:':
        request = kit.require('http').request;
        break;
      case 'https:':
        request = kit.require('https').request;
        break;
      default:
        Promise.reject(new Error('Protocol not supported: ' + url.protocol));
    }
    _.defaults(opts, url);
    _.defaults(opts, {
      body: true,
      resEncoding: 'auto',
      reqData: null,
      autoEndReq: true,
      autoUnzip: true,
      reqProgress: null,
      resProgress: null
    });
    if (opts.headers == null) {
      opts.headers = {};
    }
    if (Buffer.isBuffer(opts.reqData)) {
      reqBuf = opts.reqData;
    } else if (_.isString(opts.reqData)) {
      reqBuf = new Buffer(opts.reqData);
    } else if (_.isObject(opts.reqData)) {
      if ((_base1 = opts.headers)['content-type'] == null) {
        _base1['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8';
      }
      reqBuf = new Buffer(_.map(opts.reqData, function(v, k) {
        return [encodeURIComponent(k), encodeURIComponent(v)].join('=');
      }).join('&'));
    } else {
      reqBuf = void 0;
    }
    if (reqBuf !== void 0) {
      if ((_base2 = opts.headers)['content-length'] == null) {
        _base2['content-length'] = reqBuf.length;
      }
    }
    if (opts.setTE) {
      opts.headers['transfer-encoding'] = 'chunked';
    }
    req = null;
    promise = new Promise(function(resolve, reject) {
      req = request(opts, function(res) {
        var buf, resPipeError, unzip;
        if (opts.redirect > 0 && res.headers.location) {
          opts.redirect--;
          url = kit.url.resolve(kit.url.format(opts), res.headers.location);
          kit.request(_.extend(opts, kit.url.parse(url))).then(resolve)["catch"](reject);
          return;
        }
        if (opts.resProgress) {
          (function() {
            var complete, total;
            total = +res.headers['content-length'];
            complete = 0;
            return res.on('data', function(chunk) {
              complete += chunk.length;
              return opts.resProgress(complete, total);
            });
          })();
        }
        if (opts.resPipe) {
          resPipeError = function(err) {
            opts.resPipe.end();
            return reject(err);
          };
          if (opts.autoUnzip) {
            switch (res.headers['content-encoding']) {
              case 'gzip':
                unzip = kit.require('zlib').createGunzip();
                break;
              case 'deflate':
                unzip = kit.require('zlib').createInflat();
                break;
              default:
                unzip = null;
            }
            if (unzip) {
              unzip.on('error', resPipeError);
              res.pipe(unzip).pipe(opts.resPipe);
            } else {
              res.pipe(opts.resPipe);
            }
          } else {
            res.pipe(opts.resPipe);
          }
          opts.resPipe.on('error', resPipeError);
          res.on('error', resPipeError);
          return res.on('end', function() {
            return resolve(res);
          });
        } else {
          buf = new Buffer(0);
          res.on('data', function(chunk) {
            return buf = Buffer.concat([buf, chunk]);
          });
          return res.on('end', function() {
            var cType, decode, encoding, m, resolver;
            resolver = function(body) {
              if (opts.body) {
                return resolve(body);
              } else {
                res.body = body;
                return resolve(res);
              }
            };
            if (opts.resEncoding) {
              if (opts.resEncoding === 'auto') {
                encoding = 'utf8';
                cType = res.headers['content-type'];
                if (_.isString(cType)) {
                  m = cType.match(/charset=(.+);?/i);
                  if (m && m[1]) {
                    encoding = m[1].toLowerCase();
                    if (encoding === 'utf-8') {
                      encoding = 'utf8';
                    }
                  }
                  if (!/^(text)|(application)\//.test(cType)) {
                    encoding = null;
                  }
                }
              } else {
                encoding = opts.resEncoding;
              }
              decode = function(buf) {
                var err;
                if (!encoding) {
                  return buf;
                }
                try {
                  if (encoding === 'utf8') {
                    return buf.toString();
                  } else {
                    return kit.requireOptional('iconv-lite').decode(buf, encoding);
                  }
                } catch (_error) {
                  err = _error;
                  return reject(err);
                }
              };
              if (opts.autoUnzip) {
                switch (res.headers['content-encoding']) {
                  case 'gzip':
                    unzip = kit.require('zlib').gunzip;
                    break;
                  case 'deflate':
                    unzip = kit.require('zlib').inflate;
                    break;
                  default:
                    unzip = null;
                }
                if (unzip) {
                  return unzip(buf, function(err, buf) {
                    return resolver(decode(buf));
                  });
                } else {
                  return resolver(decode(buf));
                }
              } else {
                return resolver(decode(buf));
              }
            } else {
              return resolver(buf);
            }
          });
        }
      });
      req.on('error', function(err) {
        var _ref;
        if ((_ref = opts.resPipe) != null) {
          _ref.end();
        }
        return reject(err);
      });
      if (opts.timeout > 0) {
        req.setTimeout(opts.timeout, function() {
          return req.emit('error', new Error('timeout'));
        });
      }
      if (opts.reqPipe) {
        if (opts.reqProgress) {
          (function() {
            var complete, total;
            total = +opts.headers['content-length'];
            complete = 0;
            return opts.reqPipe.on('data', function(chunk) {
              complete += chunk.length;
              return opts.reqProgress(complete, total);
            });
          })();
        }
        return opts.reqPipe.pipe(req);
      } else {
        if (opts.autoEndReq) {
          return req.end(reqBuf);
        }
      }
    });
    promise.req = req;
    return promise;
  },

  /**
  	 * A safer version of `child_process.spawn` to cross-platform run
  	 * a process. In some conditions, it may be more convenient
  	 * to use the `kit.exec`.
  	 * It will automatically add `node_modules/.bin` to the `PATH`
  	 * environment variable.
  	 * @param  {String} cmd Path or name of an executable program.
  	 * @param  {Array} args CLI arguments.
  	 * @param  {Object} opts Process options.
  	 * Same with the Node.js official documentation.
  	 * Except that it will inherit the parent's stdio.
  	 * @return {Promise} The `promise.process` is the spawned child
  	 * process object.
  	 * **Resolves** when the process's stdio is drained and the exit
  	 * code is either `0` or `130`. The resolve value
  	 * is like:
  	 * ```coffee
  	 * {
  	 * 	code: 0
  	 * 	signal: null
  	 * }
  	 * ```
  	 * @example
  	 * ```coffee
  	 * kit.spawn 'git', ['commit', '-m', '42 is the answer to everything']
  	 * .then ({code}) -> kit.log code
  	 * ```
   */
  spawn: function(cmd, args, opts) {
    var PATH, cmdSrc, m, promise, ps, spawn, which;
    if (args == null) {
      args = [];
    }
    if (opts == null) {
      opts = {};
    }
    PATH = process.env.PATH || process.env.Path;
    [kit.path.normalize(__dirname + '/../node_modules/.bin'), kit.path.normalize(process.cwd() + '/node_modules/.bin')].forEach(function(path) {
      if (PATH.indexOf(path) < 0 && kit.fs.existsSync(path)) {
        return PATH = [path, PATH].join(kit.path.delimiter);
      }
    });
    process.env.PATH = PATH;
    process.env.Path = PATH;
    _.defaults(opts, {
      stdio: 'inherit'
    });
    if (process.platform === 'win32') {
      which = kit.require('which');
      cmd = which.sync(cmd);
      if (cmd.slice(-3).toLowerCase() === 'cmd') {
        cmdSrc = kit.fs.readFileSync(cmd, 'utf8');
        m = cmdSrc.match(/node\s+"%~dp0\\(\.\.\\.+)"/);
        if (m && m[1]) {
          cmd = kit.path.join(cmd, '..', m[1]);
          cmd = kit.path.normalize(cmd);
          args = [cmd].concat(args);
          cmd = 'node';
        }
      }
    }
    spawn = kit.require('child_process').spawn;
    ps = null;
    promise = new Promise(function(resolve, reject) {
      var err;
      try {
        ps = spawn(cmd, args, opts);
      } catch (_error) {
        err = _error;
        reject(err);
      }
      ps.on('error', function(err) {
        return reject(err);
      });
      return ps.on('close', function(code, signal) {
        if (code === null || code === 0 || code === 130) {
          return resolve({
            code: code,
            signal: signal
          });
        } else {
          return reject({
            code: code,
            signal: signal
          });
        }
      });
    });
    promise.process = ps;
    return promise;
  },

  /**
  	 * Node native module `url`.
   */
  url: require('url'),

  /**
  	 * Walk through path pattern recursively.
  	 * For more doc, see the [glob](https://github.com/isaacs/node-glob)
  	 *
  	 * [Offline Documentation](?gotoDoc=glob/readme.md)
  	 * @param  {String}   patterns The path minimatch pattern.
  	 * @param  {Object}   opts     Same with the `glob`. Optional.
  	 * @param  {Function} fn       Called on each path match.
  	 * @return {Promise} Same with the `kit.glob`.
  	 * @example
  	 * ```coffee
  	 * kit.walk '.\/**\/*.js', (path) ->
  	 * 	kit.log path
  	 * .then (paths) ->
  	 * 	kit.log paths
  	 *
  	 * 	# You can also get the glob object.
  	 * 	kit.log paths.glob
  	 * ```
   */
  walk: function(pattern, opts, fn) {
    var glob;
    glob = kit.require('glob');
    if (_.isFunction(opts)) {
      fn = opts;
      opts = {};
    }
    if (opts == null) {
      opts = {};
    }
    return new Promise(function(resolve, reject) {
      var err, g;
      if (opts.sync) {
        try {
          g = new glob.Glob(pattern, opts);
          resolve(g.found);
        } catch (_error) {
          err = _error;
          reject(err);
        }
      } else {
        g = new glob.Glob(pattern, opts, function(err, matches) {
          if (err) {
            return reject(err);
          } else {
            matches.glob = g;
            return resolve(matches);
          }
        });
      }
      if (fn) {
        return g.on('match', fn);
      }
    });
  },

  /**
  	 * Watch a file. If the file changes, the handler will be invoked.
  	 * You can change the polling interval by using `process.env.pollingWatch`.
  	 * Use `process.env.watchPersistent = 'off'` to disable the persistent.
  	 * Why not use `fs.watch`? Because `fs.watch` is unstable on some file
  	 * systems, such as Samba or OSX.
  	 * @param  {String}   path    The file path
  	 * @param  {Function} handler Event listener.
  	 * The handler has these params:
  	 * - file path
  	 * - current `fs.Stats`
  	 * - previous `fs.Stats`
  	 * - if its a deletion
  	 * @param {Boolean} autoUnwatch Auto unwatch the file while file deletion.
  	 * Default is true.
  	 * @return {Function} The wrapped watch listeners.
  	 * @example
  	 * ```coffee
  	 * process.env.watchPersistent = 'off'
  	 * kit.watchFile 'a.js', (path, curr, prev, isDeletion) ->
  	 * 	if curr.mtime != prev.mtime
  	 * 		kit.log path
  	 * ```
   */
  watchFile: function(path, handler, autoUnwatch) {
    var listener;
    if (autoUnwatch == null) {
      autoUnwatch = true;
    }
    listener = function(curr, prev) {
      var isDeletion;
      isDeletion = curr.mtime.getTime() === 0;
      handler(path, curr, prev, isDeletion);
      if (isDeletion) {
        return kit.fs.unwatchFile(path, listener);
      }
    };
    fs.watchFile(path, {
      persistent: process.env.watchPersistent !== 'off',
      interval: +process.env.pollingWatch || 300
    }, listener);
    return listener;
  },

  /**
  	 * Watch files, when file changes, the handler will be invoked.
  	 * It is build on the top of `kit.watchFile`.
  	 * @param  {Array} patterns String array with minimatch syntax.
  	 * Such as `['*\/**.css', 'lib\/**\/*.js']`.
  	 * @param  {Function} handler
  	 * @return {Promise} It contains the wrapped watch listeners.
  	 * @example
  	 * ```coffee
  	 * kit.watchFiles '*.js', (path, curr, prev, isDeletion) ->
  	 * 	kit.log path
  	 * ```
   */
  watchFiles: function(patterns, handler) {
    return kit.glob(patterns).then(function(paths) {
      return paths.map(function(path) {
        return kit.watchFile(path, handler);
      });
    });
  },

  /**
  	 * Watch directory and all the files in it.
  	 * It supports three types of change: create, modify, move, delete.
  	 * It is build on the top of `kit.watchFile`.
  	 * @param  {Object} opts Defaults:
  	 * ```coffee
  	 * {
  	 * 	dir: '.'
  	 * 	pattern: '**' # minimatch, string or array
  	 *
  	 * 	# Whether to watch POSIX hidden file.
  	 * 	dot: false
  	 *
  	 * 	# If the "path" ends with '/' it's a directory, else a file.
  	 * 	handler: (type, path, oldPath) ->
  	 * }
  	 * ```
  	 * @return {Promise}
  	 * @example
  	 * ```coffee
  	 * # Only current folder, and only watch js and css file.
  	 * kit.watchDir {
  	 * 	dir: 'lib'
  	 * 	pattern: '*.+(js|css)'
  	 * 	handler: (type, path) ->
  	 * 		kit.log type
  	 * 		kit.log path
  	 *
  	 * 	# If you use watchDir recursively, you need a global watchedList
  	 * 	watchedList: {}
  	 * }
  	 * ```
   */
  watchDir: function(opts) {
    var expandPaths, expandPatterns, fileWatcher, isSameFile, mainWatch, recursiveWatch;
    _.defaults(opts, {
      dir: '.',
      pattern: '**',
      dot: false,
      handler: function(type, path, oldPath) {},
      watchedList: {},
      deletedList: {}
    });
    if (_.isString(opts.pattern)) {
      opts.pattern = [opts.pattern];
      opts.pattern = _.uniq(opts.pattern);
    }
    opts.pattern.push('**/');
    expandPatterns = opts.pattern.map(function(pattern) {
      return kit.path.join(opts.dir, pattern);
    });
    expandPaths = function(paths) {
      paths.push(kit.path.join(opts.dir, kit.path.sep));
      return _.uniq(paths.sort(), true).reverse();
    };
    isSameFile = function(statsA, statsB) {
      return statsA.mtime.getTime() === statsB.mtime.getTime() && statsA.ctime.getTime() === statsB.ctime.getTime() && statsA.size === statsB.size;
    };
    recursiveWatch = function(path) {
      if (path.slice(-1) === '/') {
        return kit.watchDir(_.defaults({
          dir: path
        }, opts));
      } else {
        return opts.watchedList[path] = kit.watchFile(path, fileWatcher);
      }
    };
    fileWatcher = function(path, curr, prev, isDelete) {
      if (isDelete) {
        return opts.deletedList[path] = prev;
      } else {
        return opts.handler('modify', path);
      }
    };
    mainWatch = function(path, curr, prev, isDelete) {
      if (isDelete) {
        opts.deletedList[path] = prev;
        return;
      }
      return kit.glob(expandPatterns, {
        mark: true,
        dot: opts.dot,
        nosort: true
      }).then(function(paths) {
        var p, statCache, _i, _len;
        statCache = paths.statCache;
        paths = expandPaths(paths);
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          p = paths[_i];
          if (opts.watchedList[p] !== void 0) {
            continue;
          }
          if (!_.any(opts.deletedList, function(stat, dpath) {
            if (stat === 'parentMoved') {
              delete opts.deletedList[dpath];
              return true;
            }
            if (isSameFile(stat, statCache[p])) {
              for (k in opts.deletedList) {
                if (k.indexOf(dpath) === 0) {
                  opts.deletedList[k] = 'parentMoved';
                  delete opts.watchedList[k];
                }
              }
              delete opts.deletedList[dpath];
              recursiveWatch(p);
              opts.handler('move', p, dpath);
              return true;
            } else {
              return false;
            }
          })) {
            recursiveWatch(p);
            opts.handler('create', p);
          }
        }
        return _.each(opts.watchedList, function(v, wpath) {
          if (__indexOf.call(paths, wpath) < 0 && wpath.indexOf(path) === 0) {
            delete opts.deletedList[wpath];
            delete opts.watchedList[wpath];
            return opts.handler('delete', wpath);
          }
        });
      })["catch"](function(err) {
        return kit.err(err);
      });
    };
    return kit.glob(expandPatterns, {
      mark: true,
      dot: opts.dot,
      nosort: true
    }).then(function(paths) {
      var path, w, _i, _len;
      paths = expandPaths(paths);
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        if (path.slice(-1) === '/') {
          w = kit.watchFile(path, mainWatch);
        } else {
          w = kit.watchFile(path, fileWatcher);
        }
        opts.watchedList[path] = w;
      }
      return opts.watchedList;
    });
  }
});

kit.path.delimiter = process.platform === 'win32' ? ';' : ':';

if (kit.isDevelopment()) {
  Promise.longStackTraces();
} else {
  colors.mode = 'none';
}

module.exports = kit;
