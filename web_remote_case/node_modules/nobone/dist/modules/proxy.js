// Generated by CoffeeScript 1.8.0

/**
 * For test, page injection development.
 * A cross-platform programmable Fiddler alternative.
 */
var Overview, http, kit, proxy, _;

Overview = 'proxy';

kit = require('../kit');

_ = kit._;

http = require('http');


/**
 * Create a Proxy instance.
 * @param  {Object} opts Defaults: `{ }`
 * @return {Proxy}
 */

proxy = function(opts) {
  var self;
  if (opts == null) {
    opts = {};
  }
  _.defaults(opts, {});
  self = {};
  self.agent = new http.Agent;

  /**
  	 * Use it to proxy one url to another.
  	 * @param {http.IncomingMessage} req Also supports Express.js.
  	 * @param {http.ServerResponse} res Also supports Express.js.
  	 * @param {String} url The target url forced to. Optional.
  	 * Such as force 'http://test.com/a' to 'http://test.com/b',
  	 * force 'http://test.com/a' to 'http://other.com/a',
  	 * force 'http://test.com' to 'other.com'.
  	 * @param {Object} opts Other options. Default:
  	 * ```coffee
  	 * {
  	 * 	bps: null # Limit the bandwidth byte per second.
  	 * 	globalBps: false # if the bps is the global bps.
  	 * 	agent: customHttpAgent
  	 * }
  	 * ```
  	 * @param {Function} err Custom error handler.
  	 * @return {Promise}
  	 * @example
  	 * ```coffee
  	 * nobone = require 'nobone'
  	 * { proxy, service } = nobone { proxy:{}, service: {} }
  	 *
  	 * service.post '/a', (req, res) ->
  	 * 	proxy.url req, res, 'a.com', (err) ->
  	 * 		kit.log err
  	 *
  	 * service.get '/b', (req, res) ->
  	 * 	proxy.url req, res, '/c'
  	 *
  	 * service.get '/a.js', (req, res) ->
  	 * 	proxy.url req, res, 'http://b.com/c.js'
  	 *
  	 * # Transparent proxy.
  	 * service.use proxy.url
  	 * ```
   */
  self.url = function(req, res, url, opts, err) {
    var bps, error, headers, k, nk, p, path, sepIndex, sockNum, stream, throttle, v, _ref;
    if (opts == null) {
      opts = {};
    }
    if (_.isObject(url)) {
      opts = url;
      url = void 0;
    }
    _.defaults(opts, {
      bps: null,
      globalBps: false,
      agent: self.agent
    });
    if (!url) {
      url = req.url;
    }
    if (_.isObject(url)) {
      url = kit.url.format(url);
    } else {
      sepIndex = url.indexOf('/');
      switch (sepIndex) {
        case 0:
          url = 'http://' + req.headers.host + url;
          break;
        case -1:
          path = kit.url.parse(req.url).path;
          url = 'http://' + url + path;
      }
    }
    error = err || function(e) {
      return kit.log(e.toString() + ' -> ' + req.url.red);
    };
    headers = {};
    _ref = req.headers;
    for (k in _ref) {
      v = _ref[k];
      nk = k.replace(/(\w)(\w*)/g, function(m, p1, p2) {
        return p1.toUpperCase() + p2;
      });
      headers[nk] = v;
    }
    stream = opts.bps === null ? res : (opts.globalBps ? (sockNum = _.keys(opts.agent.sockets).length, bps = opts.bps / (sockNum + 1)) : bps = opts.bps, throttle = new kit.requireOptional('throttle')(bps), throttle.pipe(res), throttle);
    p = kit.request({
      method: req.method,
      url: url,
      headers: headers,
      reqPipe: req,
      resPipe: stream,
      autoUnzip: false,
      agent: opts.agent
    });
    p.req.on('response', function(proxyRes) {
      return res.writeHead(proxyRes.statusCode, proxyRes.headers);
    });
    return p["catch"](error);
  };

  /**
  	 * Http CONNECT method tunneling proxy helper.
  	 * Most times used with https proxing.
  	 * @param {http.IncomingMessage} req
  	 * @param {net.Socket} sock
  	 * @param {Buffer} head
  	 * @param {String} host The host force to. It's optional.
  	 * @param {Int} port The port force to. It's optional.
  	 * @param {Function} err Custom error handler.
  	 * @example
  	 * ```coffee
  	 * nobone = require 'nobone'
  	 * { proxy, service } = nobone { proxy:{}, service: {} }
  	 *
  	 * # Directly connect to the original site.
  	 * service.server.on 'connect', proxy.connect
  	 * ```
   */
  self.connect = function(req, sock, head, host, port, err) {
    var error, h, net, p, psock;
    net = kit.require('net');
    h = host || req.headers.host;
    p = port || req.url.match(/:(\d+)$/)[1] || 443;
    psock = new net.Socket;
    psock.connect(p, h, function() {
      psock.write(head);
      return sock.write("HTTP/" + req.httpVersion + " 200 Connection established\r\n\r\n");
    });
    sock.pipe(psock);
    psock.pipe(sock);
    error = err || function(err, socket) {
      kit.log(err.toString() + ' -> ' + req.url.red);
      return socket.end();
    };
    sock.on('error', function(err) {
      return error(err, sock);
    });
    return psock.on('error', function(err) {
      return error(err, psock);
    });
  };

  /**
  	 * A pac helper.
  	 * @param {String} currHost The current host for proxy server. It's optional.
  	 * @param  {Function} ruleHandler Your custom pac rules.
  	 * It gives you three helpers.
  	 * ```coffee
  	 * url # The current client request url.
  	 * host # The host name derived from the url.
  	 * currHost = 'PROXY host:port;' # Nobone server host address.
  	 * direct =  "DIRECT;"
  	 * match = (pattern) -> # A function use shExpMatch to match your url.
  	 * proxy = (target) -> # return 'PROXY target;'.
  	 * ```
  	 * @return {Function} Express Middleware.
  	 * ```coffee
  	 * nobone = require 'nobone'
  	 * { proxy, service } = nobone { proxy:{}, service: {} }
  	 *
  	 * service.get '/pac', proxy.pac ->
  	 * 	if match 'http://a.com/*'
  	 * 		currHost
  	 * 	else if url == 'http://c.com'
  	 * 		proxy 'd.com:8123'
  	 * 	else
  	 * 		direct
  	 * ```
   */
  self.pac = function(currHost, ruleHandler) {
    if (_.isFunction(currHost)) {
      ruleHandler = currHost;
      currHost = null;
    }
    return function(req, res, next) {
      var addr, pacStr, url;
      addr = req.socket.address();
      if (currHost == null) {
        currHost = "" + addr.address + ":" + addr.port;
      }
      url = kit.url.parse(req.url);
      if (url.host == null) {
        url.host = req.headers.host;
      }
      kit.log(url);
      if (url.host !== currHost) {
        return next();
      }
      pacStr = "FindProxyForURL = function (url, host) {\n	var currHost = \"PROXY " + currHost + ";\";\n	var direct = \"DIRECT;\";\n	var match = function (pattern) {\n		return shExpMatch(url, pattern);\n	};\n	var proxy = function (target) {\n		return 'PROXY ' + target + ';';\n	};\n\n	return (" + (ruleHandler.toString()) + ")();\n}";
      res.set('Content-Type', 'application/x-ns-proxy-autoconfig');
      return res.send(pacStr);
    };
  };
  return self;
};

module.exports = proxy;
