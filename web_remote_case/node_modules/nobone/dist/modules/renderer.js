// Generated by CoffeeScript 1.8.0

/**
 * An abstract renderer for any content, such as source code or image files.
 * It automatically uses high performance memory cache.
 * This renderer helps nobone to build a **passive compilation architecture**.
 * You can run the benchmark to see the what differences it makes.
 * Even for huge project the memory usage is negligible.
 * @extends {events.EventEmitter} [Documentation](http://nodejs.org/api/events.html#eventsClassEventsEventemitter)
 */
var EventEmitter, Overview, Promise, Renderer, express, fs, kit, renderer, rendererWidgets, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Overview = 'renderer';

kit = require('../kit');

express = require('express');

EventEmitter = require('events').EventEmitter;

_ = kit._, Promise = kit.Promise, fs = kit.fs;

rendererWidgets = require('./rendererWidgets');


/**
 * Create a Renderer instance.
 * @param {Object} opts Defaults:
 * ```coffee
 * {
 * 	enableWatcher: kit.isDevelopment()
 * 	autoLog: kit.isDevelopment()
 *
 * 	# If renderer detects this pattern, it will auto-inject `noboneClient.js`
 * 	# into the page.
 * 	injectClientReg: /<html[^<>]*>[\s\S]*<\/html>/i
 *
 * 	cacheDir: '.nobone/rendererCache'
 * 	cacheLimit: 1024

 * 	fileHandlers: {
 * 		'.html': {
 * 			default: true
 * 			extSrc: ['.tpl','.ejs', '.jade']
 * 			extraWatch: { path1: 'comment1', path2: 'comment2', ... } # Extra files to watch.
 * 			encoding: 'utf8' # optional, default is 'utf8'
 * 			dependencyReg: {
 * 				'.ejs': /<%[\n\r\s]*include\s+([^\r\n]+)\s*%>/g
 * 			}
 * 			compiler: (str, path, data) -> ...
 * 		}
 *
 * 		# Simple coffee compiler
 * 		'.js': {
 * 			extSrc: '.coffee'
 * 			compiler: (str, path) -> ...
 * 		}
 *
 * 		# Browserify a main entrance file.
 * 		'.jsb': {
 * 			type: '.js'
 * 			extSrc: '.coffee'
 * 			dependencyReg: /require\s+([^\r\n]+)/g
 * 			compiler: (str, path) -> ...
 * 		}
 * 		'.css': {
 * 			extSrc: ['.styl', '.less', '.sass', '.scss']
 * 			compiler: (str, path) -> ...
 * 		}
 * 		'.md': {
 * 			type: 'html' # Force type, optional.
 * 			extSrc: ['.md', '.markdown']
 * 			compiler: (str, path) -> ...
 * 		}
 * 	}
 * }
 * ```
 * @return {Renderer}
 */

renderer = function(opts) {
  return new Renderer(opts);
};

Renderer = (function(_super) {
  __extends(Renderer, _super);

  function Renderer(opts) {
    var cacheFromFile, cachePool, cacheToFile, emit, forceExt, genHandler, genWatchList, getCache, getCompiled, getDependencies, getSrc, jhash, relate, removeExt, renderQueue, self, setSourceMap, watchSrc;
    if (opts == null) {
      opts = {};
    }
    Renderer.__super__.constructor.apply(this, arguments);
    _.defaults(opts, {
      enableWatcher: kit.isDevelopment(),
      autoLog: kit.isDevelopment(),
      injectClientReg: /<html[^<>]*>[\s\S]*<\/html>/i,
      cacheDir: '.nobone/rendererCache',
      cacheLimit: 1024,
      fileHandlers: rendererWidgets.genFileHandlers()
    });
    self = this;
    self.opts = opts;
    cachePool = {};
    renderQueue = {};

    /**
    	 * You can access all the fileHandlers here.
    	 * Manipulate them at runtime.
    	 * @type {Object}
    	 * @example
    	 * ```coffee
    	 * { renderer } = nobone()
    	 * renderer.fileHandlers['.css'].compiler = (str, path) ->
    	 * 	stylus = kit.requireOptional 'stylus'
    	 *
    	 * 	compile = stylus(str, data).set 'filename', path
    	 * 	# Take advantage of the syntax parser.
    	 * 	this.dependencyPaths = compile.deps()
    	 * 	kit.promisify(compile.render, compile)()
    	 * ```
     */
    self.fileHandlers = opts.fileHandlers;

    /**
    	 * The cache pool of the result of `fileHandlers.compiler`
    	 * @type {Object} Key is the file path.
     */
    self.cachePool = cachePool;

    /**
    	 * Set a service for listing directory content, similar with the `serve-index` project.
    	 * @param  {String | Object} opts If it's a string it represents the rootDir.
    	 * @return {Middleware} Experss.js middleware.
     */
    self.dir = rendererWidgets.dir;

    /**
    	 * Set a static directory proxy.
    	 * Automatically compile, cache and serve source files for both deveopment and production.
    	 * @param  {String | Object} opts If it's a string it represents the rootDir.
    	 * of this static directory. Defaults:
    	 * ```coffee
    	 * {
    	 * 	rootDir: '.'
    	 *
    	 * 	# Whether enable serve direcotry index.
    	 * 	index: kit.isDevelopment()
    	 *
    	 * 	injectClient: kit.isDevelopment()
    	 *
    	 * 	# Useful when mapping a normal path to a hashed file.
    	 * 	# Such as map 'lib/main.js' to 'lib/main-jk2x.js'.
    	 * 	reqPathHandler: decodeURIComponent
    	 *
    	 * 	# Check path such as '../../../../etc/passwd'.
    	 * 	isMalicious: ->
    	 * }
    	 * ```
    	 * @return {Middleware} Experss.js middleware.
     */
    self["static"] = function(opts) {
      return rendererWidgets["static"](self, opts);
    };

    /**
    	 * An extra version of `renderer.static`.
    	 * Better support for markdown and source file.
    	 * @param  {String | Object} opts If it's a string it represents the rootDir.
    	 * of this static directory. Defaults:
    	 * ```coffee
    	 * {
    	 * 	rootDir: '.'
    	 *
    	 * 	# Whether enable serve direcotry index.
    	 * 	index: kit.isDevelopment()
    	 *
    	 * 	injectClient: kit.isDevelopment()
    	 *
    	 * 	# Useful when mapping a normal path to a hashed file.
    	 * 	# Such as map 'lib/main.js' to 'lib/main-jk2x.js'.
    	 * 	reqPathHandler: decodeURIComponent
    	 * }
    	 * ```
    	 * @return {Middleware} Experss.js middleware.
     */
    self.staticEx = function(opts) {
      return rendererWidgets.staticEx(self, opts);
    };

    /**
    	 * Render a file. It will auto-detect the file extension and
    	 * choose the right compiler to handle the content.
    	 * @param  {String | Object} path The file path. The path extension should be
    	 * the same with the compiled result file. If it's an object, it can contain
    	 * any number of following params.
    	 * @param  {String} ext Force the extension. Optional.
    	 * @param  {Object} data Extra data you want to send to the compiler. Optional.
    	 * @param  {Boolean} isCache Whether to cache the result,
    	 * default is true. Optional.
    	 * @param {String} reqPath The http request path. Support it will make auto-reload
    	 * more efficient.
    	 * @param {FileHandler} handler A custom file handler.
    	 * @return {Promise} Contains the compiled content.
    	 * @example
    	 * ```coffee
    	 * # The 'a.ejs' file may not exists, it will auto-compile
    	 * # the 'a.ejs' or 'a.html' to html.
    	 * renderer.render('a.html').done (html) -> kit.log(html)
    	 *
    	 * # if the content of 'a.ejs' is '<% var a = 10 %><%= a %>'
    	 * renderer.render('a.ejs', '.html').done (html) -> html == '10'
    	 * renderer.render('a.ejs').done (str) -> str == '<% var a = 10 %><%= a %>'
    	 * ```
     */
    self.render = function(path, ext, data, isCache, reqPath, handler) {
      var err, p, _ref, _ref1;
      if (_.isObject(path)) {
        _ref = path, path = _ref.path, ext = _ref.ext, data = _ref.data, isCache = _ref.isCache, reqPath = _ref.reqPath, handler = _ref.handler;
      }
      if (_.isString(ext)) {
        path = forceExt(path, ext);
      } else if (_.isBoolean(ext)) {
        handler = reqPath;
        reqPath = data;
        isCache = ext;
        data = void 0;
      } else {
        _ref1 = [ext, data, isCache, reqPath], data = _ref1[0], isCache = _ref1[1], reqPath = _ref1[2], handler = _ref1[3];
      }
      if (isCache == null) {
        isCache = true;
      }
      handler = genHandler(path, handler);
      if (handler) {
        if (renderQueue[handler.key]) {
          return renderQueue[handler.key];
        }
        handler.data = data;
        handler.reqPath = reqPath;
        p = isCache ? getCache(handler) : getSrc(handler);
        p = p.then(function(handler) {
          return getCompiled(handler.extBin, handler, isCache);
        });
        p.handler = handler;
        p["catch"](function() {}).then(function() {
          return delete renderQueue[handler.key];
        });
        return renderQueue[handler.key] = p;
      } else {
        err = new Error('No matched content handler for:' + path);
        err.name = 'noMatchedHandler';
        return Promise.reject(err);
      }
    };

    /**
    	 * Release the resources.
     */
    self.close = function() {
      var path, _results;
      _results = [];
      for (path in cachePool) {
        _results.push(self.releaseCache(path));
      }
      return _results;
    };

    /**
    	 * Release memory cache of a file.
    	 * @param  {String} path
     */
    self.releaseCache = function(path) {
      var handler, watcher, wpath, _ref;
      handler = cachePool[path];
      handler.deleted = true;
      if (handler.watchedList) {
        _ref = handler.watchedList;
        for (wpath in _ref) {
          watcher = _ref[wpath];
          fs.unwatchFile(wpath, watcher);
        }
      }
      return delete cachePool[path];
    };
    self.e = {};

    /**
    	 * @event {compiled}
    	 * @param {String} path The compiled file.
    	 * @param {String} content Compiled content.
    	 * @param {FileHandler} handler The current file handler.
     */
    self.e.compiled = 'compiled';

    /**
    	 * @event {compileError}
    	 * @param {String} path The error file.
    	 * @param {Error} err The error info.
     */
    self.e.compileError = 'compileError';

    /**
    	 * @event {watchFile}
    	 * @param {String} path The path of the file.
    	 * @param {fs.Stats} curr Current state.
    	 * @param {fs.Stats} prev Previous state.
     */
    self.e.watchFile = 'watchFile';

    /**
    	 * @event {fileDeleted}
    	 * @param {String} path The path of the file.
     */
    self.e.fileDeleted = 'fileDeleted';

    /**
    	 * @event {fileModified}
    	 * @param {String} path The path of the file.
     */
    self.e.fileModified = 'fileModified';
    jhash = new kit.jhash.constructor;
    relate = function(p) {
      var m, rp;
      rp = kit.path.relative(process.cwd(), p);
      m = rp.match(/\.\.\//g);
      if (m && m.length > 3) {
        return p;
      } else {
        return rp;
      }
    };
    emit = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (opts.autoLog) {
        if (args[0] === 'compileError') {
          kit.err(args[1].yellow + '\n' + (args[2] + '').red);
        } else {
          kit.log([args[0].cyan].concat(args.slice(1)).join(' | '.grey));
        }
      }
      return self.emit.apply(self, args);
    };
    setSourceMap = function(handler) {
      var flag;
      if (_.isObject(handler.sourceMap)) {
        handler.sourceMap = JSON.stringify(handler.sourceMap);
      }
      handler.sourceMap = (new Buffer(handler.sourceMap)).toString('base64');
      flag = 'sourceMappingURL=data:application/json;base64,';
      return handler.sourceMap = handler.extBin === '.js' ? "\n//# " + flag + handler.sourceMap + "\n" : "\n/*# " + flag + handler.sourceMap + " */\n";
    };

    /**
    	 * Set the handler's source property.
    	 * @private
    	 * @param  {fileHandler} handler
    	 * @return {Promise} Contains handler
     */
    getSrc = function(handler) {
      var checkSrc, paths, readfile;
      readfile = function(path) {
        handler.path = kit.path.resolve(path);
        handler.ext = kit.path.extname(path);
        return kit.readFile(path, handler.encoding).then(function(source) {
          handler.source = source;
          delete handler.content;
          return handler;
        });
      };
      paths = handler.extSrc.map(function(el) {
        return handler.noExtPath + el;
      });
      checkSrc = function() {
        var path;
        path = paths.shift();
        if (!path) {
          return Promise.resolve();
        }
        return kit.fileExists(path).then(function(exists) {
          if (exists) {
            return readfile(path);
          } else {
            return checkSrc();
          }
        });
      };
      return checkSrc().then(function(ret) {
        var path;
        if (ret) {
          return ret;
        }
        path = handler.noExtPath + handler.extBin;
        return kit.fileExists(path).then(function(exists) {
          var err;
          if (exists) {
            return readfile(path);
          } else {
            err = new Error('File not exists: ' + path);
            err.name = 'fileNotExists';
            return Promise.reject(err);
          }
        });
      });
    };

    /**
    	 * Get the compiled code
    	 * @private
    	 * @param  {String}  extBin
    	 * @param  {FileHandler}  cache
    	 * @param  {Boolean} isCache
    	 * @return {Promise} Contains the compiled content.
     */
    getCompiled = function(extBin, handler, isCache) {
      if (isCache == null) {
        isCache = true;
      }
      handler.lastExtBin = extBin;
      if (extBin === handler.ext && !handler.forceCompile) {
        if (opts.enableWatcher && isCache && !handler.deleted) {
          watchSrc(handler);
        }
        return Promise.resolve(handler.source);
      } else if (handler.content) {
        return Promise.resolve(handler.content);
      } else {
        return cacheFromFile(handler).then(function(contentCache) {
          var err;
          if (contentCache !== void 0) {
            return contentCache;
          }
          try {
            return handler.compiler(handler.source, handler.path, handler.data);
          } catch (_error) {
            err = _error;
            return Promise.reject(err);
          }
        }).then(function(content) {
          handler.content = content;
          if (handler.sourceMap) {
            setSourceMap(handler);
          }
          return delete handler.error;
        })["catch"](function(err) {
          if (_.isString(err)) {
            err = new Error(err);
          }
          emit(self.e.compileError, relate(handler.path), err);
          err.name = self.e.compileError;
          return handler.error = err;
        }).then(function() {
          if (opts.enableWatcher && isCache && !handler.deleted) {
            watchSrc(handler);
          }
          if (handler.error) {
            return Promise.reject(handler.error);
          } else {
            self.emit.call(self, self.e.compiled, handler.path, handler.content, handler);
            return Promise.resolve(handler.content);
          }
        });
      }
    };

    /**
    	 * Get the compiled source code from file system.
    	 * For a better restart performance.
    	 * @private
    	 * @param  {FileHandler} handler
    	 * @return {Promise}
     */
    cacheFromFile = function(handler) {
      if (!handler.enableFileCache) {
        return Promise.resolve();
      }
      handler.fileCachePath = kit.path.join(self.opts.cacheDir, jhash.hash(handler.path, true) + '-' + kit.path.basename(handler.path));
      return kit.readJSON(handler.fileCachePath + '.json')["catch"](function(err) {
        return Promise.reject(new Error('cannotRead'));
      }).then(function(info) {
        handler.cacheInfo = info;
        return Promise.all(_(info.dependencies).keys().map(function(path) {
          return kit.stat(path).then(function(stats) {
            return info.dependencies[path] >= stats.mtime.getTime();
          });
        }).value());
      }).then(function(latestList) {
        if (_.all(latestList)) {
          handler.dependencyPaths = _.keys(handler.cacheInfo.dependencies);
          switch (handler.cacheInfo.type) {
            case 'String':
              return kit.readFile(handler.fileCachePath, 'utf8');
            case 'Buffer':
              return kit.readFile(handler.fileCachePath);
          }
        }
      })["catch"](function(err) {
        if (err.message === 'cannotRead') {
          return;
        }
        return kit.err(err);
      });
    };

    /**
    	 * Save the compiled source code to file system.
    	 * For a better restart performance.
    	 * @private
    	 * @param  {FileHandler} handler
    	 * @return {Promise}
     */
    cacheToFile = function(handler) {
      var cacheInfo, content;
      if (!handler.enableFileCache) {
        return;
      }
      switch (handler.content.constructor.name) {
        case 'String':
        case 'Buffer':
          content = handler.content;
          break;
        default:
          return;
      }
      cacheInfo = {
        type: content.constructor.name,
        dependencies: {}
      };
      return Promise.all([
        kit.outputFile(handler.fileCachePath, content), Promise.all(_.map(handler.watchedList, function(v, path) {
          return kit.stat(path).then(function(stats) {
            return cacheInfo.dependencies[path] = stats.mtime.getTime();
          });
        })).then(function() {
          return kit.outputJson(handler.fileCachePath + '.json', cacheInfo);
        })
      ]);
    };

    /**
    	 * Set handler cache.
    	 * @param  {FileHandler} handler
    	 * @return {Promise}
     */
    getCache = function(handler) {
      var cachedHandler;
      if (handler.compiler == null) {
        handler.compiler = function(bin) {
          return bin;
        };
      }
      cachedHandler = _.find(cachePool, function(v, k) {
        var ext, _i, _len, _ref;
        _ref = handler.extSrc.concat(handler.extBin);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ext = _ref[_i];
          if (handler.noExtPath + ext === k) {
            return true;
          }
        }
        return false;
      });
      if (cachedHandler === void 0) {
        return getSrc(handler).then(function(cachedHandler) {
          var minHandler;
          cachePool[cachedHandler.path] = cachedHandler;
          if (_.keys(cachePool).length > opts.cacheLimit) {
            minHandler = _(cachePool).values().min('ctime').value();
            if (minHandler) {
              self.releaseCache(minHandler.path);
            }
          }
          return cachedHandler;
        });
      } else {
        if (cachedHandler.error) {
          return Promise.reject(cachedHandler.error);
        } else {
          return Promise.resolve(cachedHandler);
        }
      }
    };

    /**
    	 * Generate a file handler.
    	 * @param  {String} path
    	 * @param  {FileHandler} handler
    	 * @return {FileHandler}
     */
    genHandler = function(path, handler) {
      var extBin;
      extBin = kit.path.extname(path);
      if (!handler) {
        if (extBin === '') {
          handler = _.find(self.fileHandlers, function(el) {
            return el["default"];
          });
        } else if (self.fileHandlers[extBin]) {
          handler = self.fileHandlers[extBin];
          if (self.fileHandlers[extBin].extSrc && __indexOf.call(self.fileHandlers[extBin].extSrc, extBin) >= 0) {
            handler.forceCompile = true;
          }
        } else {
          handler = _.find(self.fileHandlers, function(el) {
            return el.extSrc && __indexOf.call(el.extSrc, extBin) >= 0;
          });
        }
      }
      if (handler) {
        handler = _.cloneDeep(handler);
        handler.key = kit.path.resolve(path);
        handler.ctime = Date.now();
        handler.cacheInfo = {};
        if (handler.dependencyPaths == null) {
          handler.dependencyPaths = [];
        }
        handler.watchedList = {};
        if (handler.extSrc == null) {
          handler.extSrc = extBin;
        }
        if (_.isString(handler.extSrc)) {
          handler.extSrc = [handler.extSrc];
        }
        handler.extBin = extBin;
        handler.encoding = handler.encoding === void 0 ? 'utf8' : handler.encoding;
        handler.dirname = kit.path.dirname(handler.key);
        handler.noExtPath = removeExt(handler.key);
        if (handler.enableFileCache == null) {
          handler.enableFileCache = true;
        }
        if (_.isString(handler.compiler)) {
          handler.compiler = self.fileHandlers[handler.compiler].compiler;
        }
        handler.opts = self.opts;
      }
      return handler;
    };

    /**
    	 * Watch the source file.
    	 * @private
    	 * @param  {fileHandler} handler
     */
    watchSrc = function(handler) {
      var watcher;
      watcher = function(path, curr, prev, isDeletion) {
        if (isDeletion) {
          self.releaseCache(path);
          return emit(self.e.fileDeleted, relate(path) + ' -> '.cyan + relate(handler.path));
        } else if (curr.mtime !== prev.mtime) {
          return getSrc(handler).then(function() {
            return getCompiled(handler.lastExtBin, handler);
          })["catch"](function() {}).then(function() {
            return emit(self.e.fileModified, relate(path), handler.type || handler.extBin, handler.reqPath);
          });
        }
      };
      return genWatchList(handler).then(function() {
        var path;
        if (_.keys(handler.newWatchList).length === 0) {
          return;
        }
        for (path in handler.newWatchList) {
          if (_.isFunction(handler.watchedList[path])) {
            continue;
          }
          handler.watchedList[path] = kit.watchFile(path, watcher);
          emit(self.e.watchFile, relate(path), handler.reqPath);
        }
        delete handler.newWatchList;
        if (handler.content) {
          return cacheToFile(handler);
        }
      });
    };
    getDependencies = function(handler, currPaths) {
      return kit.parseDependency(handler.path, {
        depReg: handler.dependencyReg,
        depRoots: handler.dependencyRoots,
        extensions: [handler.ext],
        handle: function(path) {
          return path.replace(/^[\s'"]+/, '').replace(/[\s'";]+$/, '');
        }
      }).then(function(paths) {
        var p, _i, _len;
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          p = paths[_i];
          handler.newWatchList[p] = null;
        }
        return handler;
      });
    };
    genWatchList = function(handler) {
      var p, path, _i, _len, _ref;
      path = handler.path;
      if (!_.isFunction(handler.watchedList[path])) {
        handler.watchedList[path] = null;
      }
      if (handler.dependencyRoots == null) {
        handler.dependencyRoots = [];
      }
      if (handler.dependencyRoots.indexOf(handler.dirname) < 0) {
        handler.dependencyRoots.push(handler.dirname);
      }
      handler.newWatchList = {};
      _.extend(handler.newWatchList, handler.extraWatch);
      handler.newWatchList[path] = handler.watchedList[path];
      _ref = handler.dependencyPaths;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        handler.newWatchList[p] = handler.watchedList[p];
      }
      if (handler.dependencyReg && !_.isRegExp(handler.dependencyReg)) {
        handler.dependencyReg = handler.dependencyReg[handler.ext];
      }
      if (handler.dependencyReg) {
        return getDependencies(handler);
      } else {
        return Promise.resolve();
      }
    };
    forceExt = function(path, ext) {
      return removeExt(path) + ext;
    };
    removeExt = function(path) {
      return path.replace(/\.\w+$/, '');
    };
  }

  return Renderer;

})(EventEmitter);

module.exports = renderer;
