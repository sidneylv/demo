// Generated by CoffeeScript 1.8.0

/**
 * It is just a Express.js wrap.
 * @extends {Express} [Documentation][http://expressjs.com/4x/api.html]
 */
var Overview, http, initRemoteLog, initSse, kit, service, _,
  __slice = [].slice;

Overview = 'service';

http = require('http');

kit = require('../kit');

_ = kit._;


/**
 * Create a Service instance.
 * @param  {Object} opts Defaults:
 * ```coffee
 * {
 * 	autoLog: kit.isDevelopment()
 * 	enableRemoteLog: kit.isDevelopment()
 * 	enableSse: kit.isDevelopment()
 * 	express: {}
 * }
 * ```
 * @return {Service}
 */

service = function(opts) {
  var express, jhash, self, server;
  if (opts == null) {
    opts = {};
  }
  _.defaults(opts, {
    autoLog: kit.isDevelopment(),
    enableRemoteLog: kit.isDevelopment(),
    enableSse: kit.isDevelopment(),
    allowOrigin: kit.isDevelopment() ? '*' : null,
    express: {}
  });
  express = require('express');
  self = express(opts.express);

  /**
  	 * The server object of the express object.
  	 * @type {http.Server} [Documentation](http://nodejs.org/api/http.html#httpClassHttpServer)
   */
  server = http.Server(self);
  self.e = {};
  self._emit = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (opts.autoLog) {
      switch (args[0]) {
        case self.e.sseConnected:
          kit.log([args[0].cyan, args[1].req.path, args[1].req.headers.referer].join(' | '.grey));
          break;
        default:
          kit.log([args[0].cyan].concat(args.slice(1)).join(' | '.grey));
      }
    }
    return self.emit.apply(self, args);
  };
  _.extend(self, {
    server: server,
    express: express,
    listen: function() {
      return server.listen.apply(server, arguments);
    },
    close: function(callback) {
      return server.close(callback);
    }
  });
  jhash = new kit.jhash.constructor;
  self.set('etag', function(body) {
    var hash, len;
    hash = jhash.hash(body);
    len = body.length.toString(36);
    return "W/\"" + len + "-" + hash + "\"";
  });
  if (opts.allowOrigin) {
    self.use(function(req, res, next) {
      res.set('Access-Control-Allow-Origin', opts.allowOrigin);
      return next();
    });
  }
  if (opts.enableRemoteLog) {
    initRemoteLog(self);
  }
  if (opts.enableSse) {
    initSse(self);
  }
  return self;
};

initRemoteLog = function(self) {
  return self.post('/nobone-log', function(req, res) {
    var data;
    data = '';
    req.on('data', function(chunk) {
      return data += chunk;
    });
    return req.on('end', function() {
      var e;
      try {
        kit.log(JSON.parse(data));
        return res.status(200).end();
      } catch (_error) {
        e = _error;
        return res.status(500).end();
      }
    });
  });
};

initSse = function(self) {

  /**
  	 * A Server-Sent Event Manager.
  	 * The namespace of nobone sse is `/nobone-sse`.
  	 * For more info see [Using server-sent events][Using server-sent events].
  	 * NoBone use it to implement the live-reload of web assets.
  	 * [Using server-sent events]: https://developer.mozilla.org/en-US/docs/Server-sentEvents/UsingServer-sentEvents
  	 * @type {SSE}
  	 * @property {Array} sessions The sessions of connected clients.
  	 * @property {Integer} retry The reconnection time to use when attempting to send the event, unit is ms.
  	 * Default is 1000ms.
  	 * A session object is something like:
  	 * ```coffee
  	 * {
  	 * 	req  # The express.js req object.
  	 * 	res  # The express.js res object.
  	 * }
  	 * ```
  	 * @example You browser code should be something like this:
  	 * ```coffee
  	 * es = new EventSource('/nobone-sse')
  	 * es.addEventListener('eventName', (e) ->
  	 * 	msg = JSON.parse(e.data)
  	 * 	console.log(msg)
  	 * ```
   */
  self.sse = {
    sessions: [],
    retry: 1000
  };

  /**
  	 * This event will be triggered when a sse connection started.
  	 * The event name is a combination of sseConnected and req.path,
  	 * for example: "sseConnected/test"
  	 * @event {sseConnected}
  	 * @param {SSESession} session The session object of current connection.
   */
  self.e.sseConnected = 'sseConnected';

  /**
  	 * This event will be triggered when a sse connection closed.
  	 * @event {sseClose}
  	 * @param {SSESession} session The session object of current connection.
   */
  self.e.sseClose = 'sseClose';

  /**
  	 * Create a sse session.
  	 * @param  {Express.req} req
  	 * @param  {Express.res} res
  	 * @return {SSESession}
   */
  self.sse.create = function(req, res) {
    var session;
    session = {
      req: req,
      res: res
    };
    req.socket.setTimeout(0);
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    });

    /**
    		 * Emit message to client.
    		 * @param  {String} event The event name.
    		 * @param  {Object | String} msg The message to send to the client.
     */
    session.emit = function(event, msg) {
      if (msg == null) {
        msg = '';
      }
      msg = JSON.stringify(msg);
      return res.write("id: " + (Date.now()) + "\nevent: " + event + "\nretry: " + self.sse.retry + "\ndata: " + msg + "\n\n");
    };
    req.on('close', function() {
      return _.remove(self.sse.sessions, function(el) {
        return el === session;
      });
    });
    session.emit('connect', 'ok');
    return session;
  };
  self.use('/nobone-sse', function(req, res) {
    var session;
    session = self.sse.create(req, res);
    self.sse.sessions.push(session);
    return self._emit(self.e.sseConnected, session);
  });

  /**
  	 * Broadcast a event to clients.
  	 * @param {String} event The event name.
  	 * @param {Object | String} msg The data you want to emit to session.
  	 * @param {String} [path] The namespace of target sessions. If not set,
  	 * broadcast to all clients.
   */
  return self.sse.emit = function(event, msg, path) {
    var el, _i, _len, _ref, _results;
    if (path == null) {
      path = '';
    }
    _ref = self.sse.sessions;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      if (!path) {
        _results.push(el.emit(event, msg));
      } else if (el.req.path === path) {
        _results.push(el.emit(event, msg));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
};

module.exports = service;
