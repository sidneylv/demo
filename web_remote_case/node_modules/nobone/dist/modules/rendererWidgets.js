// Generated by CoffeeScript 1.8.0

/**
 * It use the renderer module to create some handy functions.
 */
var Overview, Promise, fs, http, kit, nobone, rendererWidgets, _;

Overview = 'rendererWidgets';

nobone = require('../nobone');

kit = require('../kit');

http = require('http');

_ = kit._, Promise = kit.Promise, fs = kit.fs;

module.exports = rendererWidgets = {
  genFileHandlers: function() {
    return {
      '.html': {
        "default": true,
        extSrc: ['.tpl', '.ejs', '.jade'],
        enableFileCache: false,
        dependencyReg: {
          '.ejs': /<%[\n\r\s]*include\s+([^\r\n]+)\s*%>/g
        },

        /**
        			 * The compiler can handle any type of file.
        			 * @context {FileHandler} Properties:
        			 * ```coffee
        			 * {
        			 * 	ext: String # The current file's extension.
        			 * 	opts: Object # The current options of renderer.
        			 *
        			 * 	# The file dependencies of current file.
        			 * 	# If you set it in the `compiler`, the `dependencyReg`
        			 * 	# and `dependencyRoots` should be left undefined.
        			 * 	dependencyPaths: Array
        			 *
        			 * 	# The regex to match dependency path. Regex or Table.
        			 * 	dependencyReg: RegExp
        			 *
        			 * 	# The root directories for searching dependencies.
        			 * 	dependencyRoots: Array
        			 *
        			 * 	# The source map informantion.
        			 * 	# If you need source map support, the `sourceMap`property
        			 * 	# must be set during the compile process.
        			 * 	# If you use inline source map, this property shouldn't be set.
        			 * 	sourceMap: String or Object
        			 * }
        			 * ```
        			 * @param  {String} str Source content.
        			 * @param  {String} path For debug info.
        			 * @param  {Any} data The data sent from the `render` function.
        			 * when you call the `render` directly. Default is an object:
        			 * ```coffee
        			 * {
        			 * 	_: lodash
        			 * 	injectClient: kit.isDevelopment()
        			 * }
        			 * ```
        			 * @return {Promise} Promise that contains the compiled content.
         */
        compiler: function(str, path, data) {
          var compiler, err, func, render, self, tplFn;
          self = this;
          switch (this.ext) {
            case '.tpl':
              tplFn = _.template(str, null, {
                sourceURL: path
              });
              break;
            case '.ejs':
              compiler = kit.requireOptional('ejs');
              tplFn = compiler.compile(str, {
                filename: path
              });
              break;
            case '.jade':
              compiler = kit.requireOptional('jade');
              tplFn = compiler.compile(str, {
                filename: path
              });
              this.dependencyPaths = tplFn.dependencies;
          }
          render = function(data) {
            var html;
            _.defaults(data, {
              _: _,
              injectClient: kit.isDevelopment()
            });
            html = tplFn(data);
            if (data.injectClient && self.opts.injectClientReg.test(html)) {
              html += nobone.client();
            }
            return html;
          };
          try {
            if (_.isObject(data)) {
              return render(data);
            } else {
              func = function(data) {
                if (data == null) {
                  data = {};
                }
                return render(data);
              };
              func.toString = function() {
                return str;
              };
              return func;
            }
          } catch (_error) {
            err = _error;
            return Promise.reject(err);
          }
        }
      },
      '.js': {
        extSrc: '.coffee',
        compiler: function(str, path, data) {
          var coffee;
          if (data == null) {
            data = {};
          }
          coffee = kit.require('coffee-script');
          return coffee.compile(str, _.defaults(data, {
            bare: true,
            compress: kit.isProduction(),
            compressOpts: {
              fromString: true
            }
          }));
        }
      },
      '.jsb': {
        type: '.js',
        dependencyReg: /require\s+([^\r\n]+)/g,
        extSrc: '.coffee',
        compiler: function(nil, path, data) {
          var b, browserify, coffee, through;
          if (data == null) {
            data = {};
          }
          browserify = kit.requireOptional('browserify');
          through = kit.requireOptional('through');
          coffee = kit.require('coffee-script');
          _.defaults(data, {
            bare: true,
            compress: kit.isProduction(),
            compressOpts: {
              fromString: true
            },
            browserify: {
              extensions: '.coffee',
              debug: kit.isDevelopment()
            }
          });
          b = browserify(data.browserify);
          b.add(path);
          b.transform(function() {
            var str;
            str = '';
            return through(function(chunk) {
              return str += chunk;
            }, function() {
              this.queue(coffee.compile(str, data));
              return this.queue(null);
            });
          });
          return kit.promisify(b.bundle, b)();
        }
      },
      '.css': {
        extSrc: ['.styl', '.less', '.sass', '.scss'],
        dependencyReg: {
          '.sass': /@import\s+([^\r\n]+)/g,
          '.scss': /@import\s+([^\r\n]+)/g
        },
        compiler: function(str, path, data) {
          var less, opts, parser, sass, self, styl, stylus;
          if (data == null) {
            data = {};
          }
          self = this;
          _.defaults(data, {
            filename: path
          });
          switch (this.ext) {
            case '.styl':
              stylus = kit.requireOptional('stylus');
              _.defaults(data, {
                sourcemap: {
                  inline: kit.isDevelopment()
                }
              });
              styl = stylus(str, data);
              this.dependencyPaths = styl.deps();
              return kit.promisify(styl.render, styl)();
            case '.less':
              if (str === '') {
                return '';
              }
              less = kit.requireOptional('less');
              if (less.version[0] < 2) {
                parser = new less.Parser(_.defaults(data, {
                  sourceMapFileInline: kit.isDevelopment(),
                  sourceMap: kit.isDevelopment()
                }));
                return new Promise(function(resolve, reject) {
                  return parser.parse(str, function(err, tree) {
                    if (err) {
                      kit.log(err.stack);
                      err.message = err.filename + (":" + err.line + ":" + err.column + "\n") + err.message;
                      return reject(err);
                    } else {
                      self.dependencyPaths = _.keys(parser.imports.files);
                      return resolve(tree.toCSS(data));
                    }
                  });
                });
              } else {
                opts = {};
                if (kit.isDevelopment()) {
                  opts = {
                    sourceMap: {
                      sourceMapFileInline: true
                    }
                  };
                }
                return less.render(str, _.defaults(data, opts)).then(function(output) {
                  self.dependencyPaths = output.imports;
                  return output.css;
                }, function(err) {
                  var _ref;
                  if (err.line == null) {
                    return Promise.reject(err);
                  }
                  err.message = err.filename + (":" + err.line + ":" + err.column + "\n") + ((_ref = err.extract) != null ? _ref.join('\n') : void 0) + '\n--------\n' + err.message;
                  return Promise.reject(err);
                });
              }
              break;
            case '.sass':
            case '.scss':
              sass = kit.requireOptional('node-sass');
              return sass.renderSync(_.defaults(data, {
                outputStyle: kit.isProduction() ? 'compressed' : 'nested',
                file: path,
                data: str,
                includePaths: [kit.path.dirname(path)]
              }));
          }
        }
      },
      '.md': {
        type: '.html',
        extSrc: ['.md', '.markdown'],
        compiler: function(str, path, data) {
          var marked;
          if (data == null) {
            data = {};
          }
          marked = kit.require('marked');
          return marked(str, data);
        }
      }
    };
  },

  /**
  	 * Folder middleware.
  	 * @param  {Object} opts
  	 * @return {Function}
   */
  dir: function(opts) {
    var renderer;
    if (opts == null) {
      opts = {};
    }
    if (_.isString(opts)) {
      opts = {
        rootDir: opts
      };
    }
    _.defaults(opts, {
      renderer: {
        enableWatcher: false,
        autoLog: false,
        cacheDir: kit.path.join(__dirname, '/../.nobone/rendererCache')
      },
      rootDir: '.',
      reqPathHandler: function(path) {
        return decodeURIComponent(path);
      }
    });
    renderer = require('./renderer')(opts.renderer);
    return function(req, res, next) {
      var path, reqPath;
      reqPath = opts.reqPathHandler(req.path);
      path = kit.path.join(opts.rootDir, reqPath);
      return kit.dirExists(path).then(function(exists) {
        if (exists) {
          if (reqPath.slice(-1) === '/') {
            return kit.readdir(path);
          } else {
            return Promise.reject('not strict dir path');
          }
        } else {
          return Promise.reject('no dir found');
        }
      }).then(function(list) {
        list.unshift('.');
        if (reqPath !== '/') {
          list.unshift('..');
        }
        return kit.async(list.map(function(p) {
          var fp;
          fp = kit.path.join(opts.rootDir, reqPath, p);
          return kit.stat(fp).then(function(stats) {
            stats.isDir = stats.isDirectory();
            if (stats.isDir) {
              stats.path = p + '/';
            } else {
              stats.path = p;
            }
            stats.ext = kit.path.extname(p);
            stats.size = stats.size;
            return stats;
          }).then(function(stats) {
            if (stats.isDir) {
              return kit.readdir(fp).then(function(list) {
                stats.dirCount = list.length;
                return stats;
              });
            } else {
              return stats;
            }
          });
        }));
      }).then(function(list) {
        var assets;
        list.sort(function(a, b) {
          return a.path.localeCompare(b.path);
        });
        list = _.groupBy(list, function(el) {
          if (el.isDir) {
            return 'dirs';
          } else {
            return 'files';
          }
        });
        if (list.dirs == null) {
          list.dirs = [];
        }
        if (list.files == null) {
          list.files = [];
        }
        assets = function(name) {
          return kit.path.join(__dirname, '../../assets/dir', name);
        };
        return kit.async([renderer.render(assets('index.html')), renderer.render(assets('default.css'))]).then(function(_arg) {
          var css, fn;
          fn = _arg[0], css = _arg[1];
          return res.send(fn({
            list: list,
            css: css,
            path: reqPath
          }));
        });
      })["catch"](function(err) {
        if (err === 'not strict dir path') {
          return res.redirect(reqPath + '/');
        }
        if (err !== 'no dir found') {
          kit.err(err);
        }
        return next();
      });
    };
  },

  /**
  	 * Static middleware.
  	 * @param  {Renderer} renderer
  	 * @param  {Object} opts
  	 * @return {Function}
   */
  "static": function(renderer, opts) {
    var dirHandler, express, staticHandler;
    if (opts == null) {
      opts = {};
    }
    express = kit.require('express');
    if (_.isString(opts)) {
      opts = {
        rootDir: opts
      };
    }
    _.defaults(opts, {
      rootDir: process.cwd(),
      index: kit.isDevelopment(),
      injectClient: kit.isDevelopment(),
      reqPathHandler: decodeURIComponent,
      isMalicious: function(path) {
        return kit.path.normalize(path).indexOf(this.rootDir) !== 0;
      }
    });
    opts.rootDir = kit.path.resolve(opts.rootDir);
    staticHandler = express["static"](opts.rootDir);
    if (opts.index) {
      dirHandler = renderer.dir({
        rootDir: opts.rootDir
      });
    }
    return function(req, res, next) {
      var p, path, reqPath, rnext;
      reqPath = opts.reqPathHandler(req.path);
      path = kit.path.join(opts.rootDir, reqPath);
      if (opts.isMalicious(path)) {
        return res.status(403).end(http.STATUS_CODES[403]);
      }
      rnext = function() {
        if (dirHandler) {
          return dirHandler(req, res, function() {
            return staticHandler(req, res, next);
          });
        } else {
          return staticHandler(req, res, next);
        }
      };
      p = renderer.render(path, true, reqPath);
      return p.then(function(content) {
        var body, err, handler;
        handler = p.handler;
        res.type(handler.type || handler.extBin);
        switch ((content != null) && content.constructor.name) {
          case 'Number':
            body = content.toString();
            break;
          case 'String':
          case 'Buffer':
            body = content;
            break;
          case 'Function':
            body = content();
            break;
          default:
            body = 'The compiler should produce a number, string, buffer or function: '.red + path.cyan + '\n' + kit.inspect(content).yellow;
            err = new Error(body);
            err.name = 'unknownType';
            Promise.reject(err);
        }
        if (opts.injectClient && res.get('Content-Type').indexOf('text/html;') === 0 && renderer.opts.injectClientReg.test(body) && body.indexOf(nobone.client()) === -1) {
          body += nobone.client();
        }
        if (handler.sourceMap) {
          body += handler.sourceMap;
        }
        return res.send(body);
      })["catch"](function(err) {
        switch (err.name) {
          case renderer.e.compileError:
            return res.status(500).end(renderer.e.compileError);
          case 'fileNotExists':
          case 'noMatchedHandler':
            return rnext();
          default:
            return Promise.reject(err);
        }
      });
    };
  },

  /**
  	 * Static middleware. Don't use it in production.
  	 * @param  {Renderer} renderer
  	 * @param  {Object} opts
  	 * @return {Function}
   */
  staticEx: function(renderer, opts) {
    var assetsRoot, noboneRoot, staticMiddleware;
    if (opts == null) {
      opts = {};
    }
    if (_.isString(opts)) {
      opts = {
        rootDir: opts
      };
    }
    _.defaults(opts, {
      rootDir: '.',
      index: kit.isDevelopment(),
      injectClient: kit.isDevelopment(),
      reqPathHandler: decodeURIComponent
    });
    noboneRoot = kit.path.join(__dirname, '../..');
    assetsRoot = kit.path.join(noboneRoot, 'assets');
    renderer.fileHandlers['.md'].compiler = function(str, path) {
      var err, marked, md, tplPath;
      marked = kit.require('marked');
      try {
        md = marked(str);
      } catch (_error) {
        err = _error;
        return Promise.reject(err);
      }
      tplPath = kit.path.join(assetsRoot, 'markdown/index.tpl');
      return kit.readFile(tplPath, 'utf8').then(function(str) {
        try {
          return _.template(str, {
            path: path,
            body: md,
            sourceURL: tplPath
          });
        } catch (_error) {
          err = _error;
          return Promise.reject(err);
        }
      });
    };
    staticMiddleware = rendererWidgets["static"](renderer, opts);
    return function(req, res, next) {
      var currModulePath, path, paths, reqPath, type, url, _i, _len;
      reqPath = opts.reqPathHandler(req.path);
      if (req.query.noboneAssets != null) {
        path = req.path.replace(/.*assets/, '');
        return res.sendFile(path, {
          root: assetsRoot
        }, function(err) {
          if (err) {
            return next();
          }
        });
      } else if (req.query.gotoDoc != null) {
        currModulePath = reqPath.replace(/\/[^\/]+$/, '/');
        paths = kit.generateNodeModulePaths(req.query.gotoDoc.replace('/', kit.path.sep), kit.path.join(opts.rootDir, currModulePath));
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          path = paths[_i];
          if (kit.fs.existsSync(path)) {
            url = kit.path.relative(opts.rootDir, path).replace(kit.path.sep, '/');
            res.redirect('/' + url + '?offlineMarkdown');
            return;
          }
        }
        return next();
      } else if (req.query.offlineMarkdown != null) {
        path = kit.path.join(opts.rootDir, reqPath);
        return kit.readFile(path, 'utf8').then(function(md) {
          md = md.replace(/!\[([^\[\]]+?)\]\(http.+?\)/g, function(m, p) {
            return p;
          });
          return renderer.fileHandlers['.md'].compiler(md, reqPath);
        }).then(function(html) {
          return res.send(html);
        })["catch"](function(err) {
          if (err.code === 'ENOENT') {
            return next();
          } else {
            kit.err(err.stack || err);
            return res.send(err.toString());
          }
        });
      } else if (req.query.source != null) {
        path = kit.path.join(opts.rootDir, reqPath);
        type = req.query.source || kit.path.extname(reqPath).slice(1) || kit.path.basename(reqPath);
        type = encodeURIComponent(type);
        return kit.readFile(path, 'utf8').then(function(str) {
          var md;
          md = "`````````" + type + "\n" + str + "\n`````````";
          return renderer.fileHandlers['.md'].compiler(md, reqPath);
        }).then(function(html) {
          return res.send(html);
        })["catch"](function(err) {
          if (err.code === 'ENOENT') {
            return next();
          } else {
            kit.err(err.stack || err);
            return res.send(err.toString());
          }
        });
      } else {
        return staticMiddleware(req, res, next);
      }
    };
  }
};
